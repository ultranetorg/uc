using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Net;
using System.Numerics;
using System.Security.Cryptography;
using System.Text;
using System.Threading.Tasks;
using Ipfs.Http;
using Nethereum.ABI.Util;
using Nethereum.BlockchainProcessing.BlockStorage.Entities;
using Nethereum.Hex.HexConvertors.Extensions;
using Nethereum.Model;
using Nethereum.Signer;
using Nethereum.Util;
using Nethereum.Web3;
using Nethereum.Web3.Accounts;
using Org.BouncyCastle.Utilities;
using Org.BouncyCastle.Utilities.Encoders;
using RocksDbSharp;

namespace UC.Net
{
	public delegate void BlockDelegate(Block b);

	public class Roundchain
	{
		class Genesis
		{
			public string Zone;
			public Cryptography Crypto;
			public string Rounds;
		}

		public const int									Pitch = 8;
		public const int									LastGenesisRound = Pitch*2;
		public const int									MembersMin = 7;
		public const int									MembersMax = 1024;
		public const int									NewMembersPerRoundMax = 1;
		public const int									MembersRotation = 32;
		const int											CacheLimit = 100_000;
		public static readonly Coin							BailMin = 1000;
		//public static readonly Coin							FundablesPercent = 10;
		public static readonly Coin							FeePerByte = new Coin(0.000001);

		public static Account								OrgAccount = Account.Parse("0x00fe929a68368c301a1906ed39016ee9be3d937b");
		public static Account								GenAccount = Account.Parse("0x00ffea61659c02c4a38d5736767bec23ab8d2875");

		public Settings										Settings;

		public List<Round>									Rounds	= new();
		public Dictionary<int, Round>						LoadedRounds = new();
		public List<Peer>									Members	= new();
		public List<Account>								Fundables = new();

		public AccountTable									Accounts;
		public AuthorTable									Authors;
		public ProductTable									Products;
		public RocksDb										Database;
		
		public Log											Log;
		public BlockDelegate								BlockAdded;

 		public static readonly Account[]					Fathers =	{
																			Account.Parse("0x000038a7a3cb80ec769c632b7b3e43525547ecd1"),
																			Account.Parse("0x00015326bcf44c84a605afbdd5343de4aaf11387"),
																			Account.Parse("0x0002a311f7cf0aabfd3a248a89824bbd94a458a2"),
																			Account.Parse("0x00031174fcd4f971249e4112f925209a16813137"),
																			Account.Parse("0x0004761973068828923e7c811dd7f5b8eee0bae5"),
																			Account.Parse("0x0005a748d15de450cd488fbed9cc3b3213f042e5"),
																			Account.Parse("0x0006680ad7845cfb115cd56f834385817e93999a"),
																			//Account.Parse("0x0007f34bc43d41cf3ec2e6f684c7b9b131b04b41"),
																			//Account.Parse("0x00086c57b20ac627f1b04b7bf50bb27330438b6b"),
																			//Account.Parse("0x0009cc6575ddd868bc1476f7ea516af58125b0dd"),
																			//Account.Parse("0x000a52cad719404896a55f2dc2ea28dc7a6a9249"),
																			//Account.Parse("0x000b2dc121bd9114e7aab47754130f6148b38755"),
																			//Account.Parse("0x000c68d29c01f7e5873a9e353ee9af4d9505be93"),
																			//Account.Parse("0x000d381af6561f165a44680afa06e2360fd1e060"),
																			//Account.Parse("0x000ea12d3b17f96ef79ef4012db9df43a3d6da1b"),
																			//Account.Parse("0x000ff3c7e0b5c19447d5175cb4c6641cfa613152"),
 																		};

		readonly static List<Genesis>						Genesises =	new()
															{
																new Genesis {Zone = Zone.Localnet, Crypto = new NoCryptography(),		 Rounds = "0001000002030000ffea61659c02c4a38d5736767bec23ab8d287500ffea61659c02c4a38d5736767bec23ab8d2875000000000000000000000000cae52b1b891b426eb611d3d4b9f04bd9cb2a67f07ea15cfd6faad225772d37f2000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000080006680ad7845cfb115cd56f834385817e93999a000000000000000000000000e21c2ea8eb293317823dec2e24c340582221c20852acb91f6e50bb16539935cc0000000201090000a0dec5adc93536c0a8016a0209000040bd8b5b936b6c000005a748d15de450cd488fbed9cc3b3213f042e500000000000000000000000072c7bda6b5b6e1c9bd185da54a427ac4ecd63bcb169cf60853942340202e40df0000000201090000a0dec5adc93536c0a801690209000040bd8b5b936b6c000004761973068828923e7c811dd7f5b8eee0bae500000000000000000000000029518bd3fb9c0add0b9f67750c457f56d491287a2efcf7e3b9508d4fa5ecde080000000201090000a0dec5adc93536c0a801680209000040bd8b5b936b6c0000031174fcd4f971249e4112f925209a16813137000000000000000000000000be1c6de468ab67294e12f3fb2d51035270fdabd977ce61c70cfa8008dd34a58a0000000201090000a0dec5adc93536c0a801670209000040bd8b5b936b6c000002a311f7cf0aabfd3a248a89824bbd94a458a2000000000000000000000000d58010ff7fc77257d315b55fe2ca073e52f53c4ef36940726b45dc640d3ff4960000000201090000a0dec5adc93536c0a801660209000040bd8b5b936b6c0000015326bcf44c84a605afbdd5343de4aaf113870000000000000000000000007305041bc0010ff74cb28ad02b48c240561e07b858787ff1f760926040aad2f30000000201090000a0dec5adc93536c0a801650209000040bd8b5b936b6c00000038a7a3cb80ec769c632b7b3e43525547ecd1000000000000000000000000be0276fb92432d1ca50dba34b1dadde226eb55b7df34c4e29f2c3ba07a9a18980000000201090000a0dec5adc93536c0a801640209000040bd8b5b936b6c0000fe929a68368c301a1906ed39016ee9be3d937b0000000000000000000000008b29284c483a63a71bf34b03946262dff271cceeee92120592ad5c2e4097fc0d000000020402756f01000208000064a7b3b6e00d000100000038a7a3cb80ec769c632b7b3e43525547ecd1000038a7a3cb80ec769c632b7b3e43525547ecd1000000000000000000000000620088857e2bd8107d10973587f7fc06938abaeec0531279c18a306f46b4bfaf00c0a801640000000000000101000001030100ffea61659c02c4a38d5736767bec23ab8d287500ffea61659c02c4a38d5736767bec23ab8d287500000000000000000000000035d8446dca69dd3a6eaa653800f696183da7aa77a8336057d44fbdec545325c5000081d8c4bd750000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100fe929a68368c301a1906ed39016ee9be3d937b00000000000000000000000029bbaa7b7e7329e29fd23c693d76676a78990fe90671b5f02879432f9f112849000101010502756f02554fff0000000000000201000001030200ffea61659c02c4a38d5736767bec23ab8d287500ffea61659c02c4a38d5736767bec23ab8d2875000000000000000000000000804dadf5a68fdcb8081cff7c20eecc1473c3fa497bd873445c77405d65a2d16d000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000301000001030300ffea61659c02c4a38d5736767bec23ab8d287500ffea61659c02c4a38d5736767bec23ab8d2875000000000000000000000000c411b500dd24679cfa2df888f2cf367e0bf358e8b3b3f240701443350a0043c0000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000401000001030400ffea61659c02c4a38d5736767bec23ab8d287500ffea61659c02c4a38d5736767bec23ab8d287500000000000000000000000049af3aecf0bc78dc679ce49da446c1b88cc028437740ee33c8cb7582134e24ef000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000501000001030500ffea61659c02c4a38d5736767bec23ab8d287500ffea61659c02c4a38d5736767bec23ab8d2875000000000000000000000000a882e6ac2371e5637f2d4c833352077dd4b81e796e13195adbffa5f217c50972000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000601000001030600ffea61659c02c4a38d5736767bec23ab8d287500ffea61659c02c4a38d5736767bec23ab8d2875000000000000000000000000394cb1e4ea94a89beaa31ba1856d4790968bf91e4ec26949d7f8c095e7413488000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000701000001030700ffea61659c02c4a38d5736767bec23ab8d287500ffea61659c02c4a38d5736767bec23ab8d28750000000000000000000000003f1ccd386b14c55191d2e582bdd0f934af01c9a15d994e0d8916d70f23051317000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000801000001030800ffea61659c02c4a38d5736767bec23ab8d287500ffea61659c02c4a38d5736767bec23ab8d28750000000000000000000000003412fce321271257a661e487e2d2542ce0557135086c802d21bdf3824abf01e10000010000000000000000000000000000000000000000000000000000000000000000000000000000000001000038a7a3cb80ec769c632b7b3e43525547ecd100000000000000000000000901000001030900ffea61659c02c4a38d5736767bec23ab8d287500ffea61659c02c4a38d5736767bec23ab8d2875000000000000000000000000582f1e753c2dffb6eb04d2248756813cc18f668973a717ab7b2e3bdcf0bb5bd50000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000100fe929a68368c301a1906ed39016ee9be3d937b0000000000000000000a01000001030a00ffea61659c02c4a38d5736767bec23ab8d287500ffea61659c02c4a38d5736767bec23ab8d2875000000000000000000000000978ab79dc2b80f04ad1164b7aa9e68aa616ca91c3cd865dfc933f397fd0b22b4000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000b01000001030b00ffea61659c02c4a38d5736767bec23ab8d287500ffea61659c02c4a38d5736767bec23ab8d2875000000000000000000000000b460acc9d77314ecf2fbb52f678dcc2f9b28638c1b68929c7eda3537c1c3b77e000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c01000001030c00ffea61659c02c4a38d5736767bec23ab8d287500ffea61659c02c4a38d5736767bec23ab8d28750000000000000000000000007d5c19519df3564d74f1c5603a1ae44cb1527f09a47afa6e4e7e56a656b57b66000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000d01000001030d00ffea61659c02c4a38d5736767bec23ab8d287500ffea61659c02c4a38d5736767bec23ab8d2875000000000000000000000000be09334cee643e44036e2572117a7c5dfc5d52938903d69bec73c9d4a2e02f02000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e01000001030e00ffea61659c02c4a38d5736767bec23ab8d287500ffea61659c02c4a38d5736767bec23ab8d287500000000000000000000000067bc8bc1fd53fcbaae8dc57b0c1fd9e87f5c89f5378155403b4b9f7004f590a8000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f01000001030f00ffea61659c02c4a38d5736767bec23ab8d287500ffea61659c02c4a38d5736767bec23ab8d2875000000000000000000000000ecef9b973a08ef34c4959f5731cfa88422ad64f41badda6140f2cbc386a25a60000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001001000001031000ffea61659c02c4a38d5736767bec23ab8d287500ffea61659c02c4a38d5736767bec23ab8d287500000000000000000000000040d8a71818e596bdfdd3f92090116adeebae60ffb3ab3e825b27b48e96f618bd0000018600a87a26ae31e103b9eb05708c5e4361f87d6fc824819258f69e26282aba25013412fce30001000038a70000000100000000000000000000000000"},
																//new Genesis {Zone = Zone.Local, Crypto = new EthereumCryptography(), Rounds = "0001000002030000ffea61659c02c4a38d5736767bec23ab8d28752118dcc5aa9c4ea5ac7a6baeb2c00fe795131249fff38aa123804415e92fc46067430454532a3445367b2f6fa24e6f0f1f71eeebf77d3f5179dbeec93eda59ea1b00000000000000000000000000000832b3d6ba18c945bbfc9baf44b52f65a449880b348520ccb42cd5fb38fc5016fe73c908ba73699e77c8c0d350ff14bc3d5f46e6d109f29cd21e4312679095a5f81b00000201090000a0dec5adc93536c0a8016a02080000c84e676dc11b000f31436863408437bf50c02865cab034aafe625d71fe4c9af7ccbbb72f7bd5b37feb8aba785eac0d60327ee7ab779525c12ee1957468336bc916c34a35273def1c00000201090000a0dec5adc93536c0a8016902080000c84e676dc11b00ae7ba257f8ae7dc6ae1c6c9a18f0947def9550a079abc02380020bea56162c37673c77412077a28c7e8e8d3803fbbdc11ff354dcf5f582d7aae42c5142a2b62e1c00000201090000a0dec5adc93536c0a8016802080000c84e676dc11b001a06703e7774c581c5f22c57e5d4ae01c7d3eb81e305ec5d32ae7521e6d53f836d9694151789a36e33dac68339f47bfe70b16c6b78fa6e8ca3ebcd44607b8ca11c00000201090000a0dec5adc93536c0a8016702080000c84e676dc11b00c97c2585746d1aed2eed862a21abeac3df1a4ceb2871429e3f40548660742159686039fdc966acc4679a8334b366c90db87333d849c5d92ed313625083f9981e1b00000201090000a0dec5adc93536c0a8016602080000c84e676dc11b006ffec6696eaf311a4e6d0b4ed03a3b8e4c7a37f8c4bd6f8e1a6568d3a58360916066f20a448846f1f5ce2fe0d494895dfc490278e38f70e94876e540f57231171b00000201090000a0dec5adc93536c0a8016502080000c84e676dc11b00e15bbcb49faa9daa8586b24aee9a1a7058b270e5325698eefb8507c7441616cf16fb8372bf549782c930b4e926affa5f30e01855a673a0142a95b730689996bb1c00000201090000a0dec5adc93536c0a8016402080000c84e676dc11b0089531e12cf910e62c26d5b8d5388527fa3d90b841955d385cfa9985482c706d054cef1778afbefa0ce61aeae488adb549b49dc29461e4348a32f6cf62d9a781a1b0000020402756f01000208000064a7b3b6e00d000100000038a7a3cb80ec769c632b7b3e43525547ecd1262509a8167f6693d39f21763f27134736a2b7ac3748f63f8bc602f7d6411ec357f4482ec576c8fca0c1e81f572ca0049461ed1c01a7cd5a1fb2fb64cdf3acf51cc0a8016400000000000101000001030100ffea61659c02c4a38d5736767bec23ab8d287515bb970258e792336b5b5a25a2776bb5545d86727877b66484e2cd938336721a6a79c88085bcefcab120b0983db1b64b6c0d3836a7a075f7672d8f96b03458b81b0081d8c4bd75000000000000000000000000011add463d846716812fb3d8992eef576e4e8aea1061a47ff5e4412fdadc32befc04e5db6b6074a017ee57b1cfce40f80f74aa7ae1b35a43212cc086bf914750c71b0101010502756f02554fff00000000000201000001030200ffea61659c02c4a38d5736767bec23ab8d2875726fa00c278d0194b0ed9b201949f2b2b579598afeeaf69a841b44149c5f9e1448ae784e390eb45adc8049beff11929d5eabfd388a29ee6713b7974541c8191a1c00010000000000000000000000000000000000000301000001030300ffea61659c02c4a38d5736767bec23ab8d28753eef6e8f4c15ddcfd8a6d7f18ed8d9f99a873523595a92a1fb4a2bc2e771bab84ddc51fcd004f55fa8a49597102d54195c18a4be6423b962bf58fa6fbe19dac61b00010000000000000000000000000000000000000401000001030400ffea61659c02c4a38d5736767bec23ab8d2875e4d286f6fd65b81e96a3612c32edcb047ee164c163fdb2443a6dbd95fde57493559f726e39eb0944f8e670005e1effe59e124e19fe9d4da5d6dc6f749c2eb7781b00010000000000000000000000000000000000000501000001030500ffea61659c02c4a38d5736767bec23ab8d28752b8041c52bc22ae8fab2e95c2a03223e84bad203db2f1bd34957e41d18a774f06a6a3e1ec12aacf994a3c8bc61d587d0984b4d223369cd38be0425f9ba9ede291b00010000000000000000000000000000000000000601000001030600ffea61659c02c4a38d5736767bec23ab8d2875511857c0b4df66d58af0c1237f1e55e3508d4232c1c9c7935b8576861ab9869c330d429aaab5587e9c19d61d4c68f0c7e5cd3223ab62ed3c09ff0f85a2d7c2be1b00010000000000000000000000000000000000000701000001030700ffea61659c02c4a38d5736767bec23ab8d2875b890b2162ca8b00993baf33d84568b67343212bf7fca18eb04e1677dd55fe7bd32e2dd35822c66d2612222a3100713eee5772719ccc244ad98480fee2292de391c00010000000000000000000000000000000000000801000001030800ffea61659c02c4a38d5736767bec23ab8d2875ee02ea3c839beb5929dc5bd7015d9a508419dffcff6d82d64fc35bb0d7c29ca66c7eaa76f023d11a5e277241b217f51458b4bbb26b695de51443b646f239131c1c0001000000000000000001000038a7a3cb80ec769c632b7b3e43525547ecd10000000000000000000901000001030900ffea61659c02c4a38d5736767bec23ab8d28752d86e829f4f3467a2a7d35411992baed3f646b25bb94da7b858320e8d92e0f153b410caa15ff00f0daef27915834118842c4ee23e918f14bd384be2b14e388841c0001000000000000000000000100fe929a68368c301a1906ed39016ee9be3d937b000000000000000a01000001030a00ffea61659c02c4a38d5736767bec23ab8d2875a1ab94398ff9ed9488233381df7aec80cd239e9f60cf5d3473a07f0c87774c7932ef58a0246dde93a989f4581c8a6a98fbb550eddafdad9b76270dbf7ae86a4e1c00010000000000000000000000000000000000000b01000001030b00ffea61659c02c4a38d5736767bec23ab8d287582bd2bf95a787747a6ded0e177430b660b59e1cd8f15eedd7473197e2bfeae2f01fe94ebd4a25c5c07b203993b873df3635eea3f558c4b04b45c824f0c7f9e551b00010000000000000000000000000000000000000c01000001030c00ffea61659c02c4a38d5736767bec23ab8d28758bdd4fe8f8a51e305c1047c3cbb60f71e49e225b62a2a9d0ad24288f24d599193c624422c21ad0a689d07222eaa574ca3ab5d74d1f4ee0e7bee7ec9713964caf1b00010000000000000000000000000000000000000d01000001030d00ffea61659c02c4a38d5736767bec23ab8d28751f7cad65a8132dd003cc78f5cd2072b968eab3fbc81723412744f687570b3d381c2a4a04902125201583da4914d9a0a3f0e8ff7a8abbd458626209269a05b2091c00010000000000000000000000000000000000000e01000001030e00ffea61659c02c4a38d5736767bec23ab8d2875756b64452b2da3d326f9f457eba3ff70c2fa91dc726b0adecb867a340ae2be256b4059e38f16a4f1bc28fb7bbf341b83de39d52bf53fff3da53a52d7981a735c1c00010000000000000000000000000000000000000f01000001030f00ffea61659c02c4a38d5736767bec23ab8d287508994bf6f6ade6ea4327286abc5e5a91d7ea8877817d1f10125ea5e5d5f347f955b7c714ff44119171552674a1b3323263f201bad656719708fd30ed3ece58fc1b00010000000000000000000000000000000000001001000001031000ffea61659c02c4a38d5736767bec23ab8d28753311bef7c11f68a9fd87a6f624f77dbcaea32116972ae7662dc30f9b562d5da77d9defa7040c6b2bac8644902e795c9e7b83e2f0e64662d89c1b6c54d62d20b71b000101763880ea0001000038a7000000010000000000000000000000"},

																new Genesis {Zone = Zone.Testnet0,	Crypto = new EthereumCryptography(), Rounds = "0001000002030000ffea61659c02c4a38d5736767bec23ab8d287533cb3ac7add11304966337c25d2c343b765e6972d481b7955b91de0822902c574345e9722b7165451470b4c2ecbf51bc3876c97a363a15209036d7153f0fa88f1b0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008841c4fbd07e9852d651286a1aad4d8bfc6ee475e02c58c8a8424308e35f176810ce46cb2e8bce6b88ec3a86484f6fd915d1ab1a9f288d369e07aa53528bcca861c00000201090000a0dec5adc935364e2fcde50209000040bd8b5b936b6c00e4b3625c1b8b4f512e8fcf3a37ab09eedf66472f7b8883cec55ef950b89ee3d92950e02222ecc6c54fc9c1b360d0cb43b1912e46427f3775917f91af16567d6f1b00000201090000a0dec5adc935364e2fc6da0209000040bd8b5b936b6c00ff54c76828026d02721dca6235422d70d20920f54bf4af72cb0067f4bc47d82705b1b27c064228710f0632b80b43ee58b3739c9d3366971f7e6e8fb09dc5d4b71c00000201090000a0dec5adc935364e2fd6ab0209000040bd8b5b936b6c007bf2930038cfe8a55c64d2e8efaea9600686e14e19d7124b1dcc46824b9501fd10337a1865893b1e9b94ae6fe16a8b62283d9f449322fd4958fe3139ef0dae8b1b00000201090000a0dec5adc935364e2fd6aa0209000040bd8b5b936b6c0093fc5d0e116b8800a96a920843dc25ac7da62aa589a94f78dca8dea745a972d3713bc66e82cce5aa68e680549eb93f3caae23f65a52a25215da7f1bca9cb5bed1c00000201090000a0dec5adc935364e2fd6a60209000040bd8b5b936b6c0081b8a20bccf847858db4d0d9debc96c06c672f2d8e33f425e3602d5c8b3a10e37f72729b4f41df7e62779ac00e6c6133b35fe21c0c6f44dfe565b92ed6bece381c00000201090000a0dec5adc935364e2fd6a10209000040bd8b5b936b6c0078725dede4f416ce7fea07335e8c585f51fc3205bb362990238ae7a3db4ffd9b3aea09dfcdc9075a4964f966eac82c660288ce2db428ba9653f66dde1dde6a171c00000201090000a0dec5adc935364e2fcc640209000040bd8b5b936b6c006c21fdae2a60eb686d65586551efb91809524ca27ccf4174d86809c5f646ef704af5af3ccad81d17691a4665906cc80d69627f1cf6b34bbb1ca7f1442e022d6f1c0000020402756f01000208000064a7b3b6e00d000100000038a7a3cb80ec769c632b7b3e43525547ecd1ed9aff0d4b41645d58886edacf4259fba842441ecffec9f080520b1beb31ecdf4df826dcb79c39b06c38df08546bd1b7fbcdf4a01a355d8474a8ddcc9af036b61c4e2fcc6400000000000101000001030100ffea61659c02c4a38d5736767bec23ab8d2875dea52621c09ec7ae411fb757a08cf3c8b0f666f4311114926453b27cfdf4adcc7d2a139fae7a0bc6ea5aa4d8b1154aa9cd08069f5234fb2797c0b3bc60a8369e1c0081d8c4bd75000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001344a20f323561bb2e6262a65e8a62360a1de13e1d3ce799516ac6268b247a56e2137826c1f634f11d14cc2f462c249460f63fc88662e921602f4d73311acd5991b0101010502756f02554fff00000000000201000001030200ffea61659c02c4a38d5736767bec23ab8d28752f7d1dd5253f25ca054505974ae86ae01f6e572caa329c39c22d8162e3aea3344f8ec3bce8ade9014a4a1e214a8ef798a5ff99426049edaa5b4ef6bdaa673ab31b000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000301000001030300ffea61659c02c4a38d5736767bec23ab8d287588c8bd67ba998789eadeeb45dc71d7bbec59699f513f566f01b465e06950f13655043faa8a4333ab837a20bb02d618eced00b12b84f7e2339aa5bf91a47b519a1c000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000401000001030400ffea61659c02c4a38d5736767bec23ab8d28751d595cdd2dc2a293e93e52393f6a2a767269e48f8b0114798e7fe6c8ee4d8a5d28a73bef43f5cda4a8b2849a205cfb1fe6031efd966bec7c4072ca5c485d47931b000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000501000001030500ffea61659c02c4a38d5736767bec23ab8d2875ed68b322797dbd2808eef00c119b46101ca380227094c8903bef1fe0881526be7b6d6c2574eaa18acee3a83f55003f6e578a3de86aa522d0ad4e681c9ac3b5c91c000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000601000001030600ffea61659c02c4a38d5736767bec23ab8d2875ff2ce26d6a5c1dc6e0b300f0e25e02c460644815614c84490dfa95ec64ed698315b09010e603ea8ad1d54be1c614b166dc9cbb5c9d18e4cbc9182a7c9fbf4bc11b000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000701000001030700ffea61659c02c4a38d5736767bec23ab8d2875d41c87cc005bbaa787873be938b8cb382e23fa74005af1e07cf5daa266e26ca302b4d45b6dfaafa343e6f4ade2c4793a91ccd830218eeed37add01b692a5cd491c000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000801000001030800ffea61659c02c4a38d5736767bec23ab8d28754181fb4d1798e4f7db57831814500476e2254206a49aac05a0ca157e2c8368796bfadc783fc0d72cb185c40b31d4923bf3eb5a71944ee4e55349c8775724e9f71c00010000000000000000000000000000000000000000000000000000000000000000000000000000000001000038a7a3cb80ec769c632b7b3e43525547ecd10000000000000000000901000001030900ffea61659c02c4a38d5736767bec23ab8d287539cbc43587904a6ab28b9920dc5a9fc3d7a41155a810dc87292b9ae13c07eb88153c58d9edee0efe3fc9a0f9c7b7384a44280952cd14170042c9d6ead596b5a41c00010000000000000000000000000000000000000000000000000000000000000000000000000000000000000100fe929a68368c301a1906ed39016ee9be3d937b000000000000000a01000001030a00ffea61659c02c4a38d5736767bec23ab8d2875dc6f77a9e890a534cf317806fe493c571c9c98e94716f548b6216dc3df92eb5b2ee01409b6f165ea28b3145b4a95dcf250c783a97eb5fea2a1d5027b7b9685141c000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000b01000001030b00ffea61659c02c4a38d5736767bec23ab8d2875162e6b4ae50f27015d47f2cc71be16c867ed870ed23510a04e9f1b18d7b6a0f64a42c4a84584ca3a96bd2373c8fea576138f7ea3d4e2dd25ff48988792fd38ae1b000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c01000001030c00ffea61659c02c4a38d5736767bec23ab8d2875affc0c8b2975d8ff55f2822dafc52bf02dc66bea66bcd70eada83ec2abfe87eb6ebcdcaab67e80ca029ea622ba1dc805a7e814ed2bc266b18822a3ce59e420971c000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000d01000001030d00ffea61659c02c4a38d5736767bec23ab8d287558338bcf99d66248eaff7a40b82853b00b718a90f8ea075d64fae8f5bde976380dbef353a561ca8949d3eecffafca24b84a1ac3bb692e8c3cadf7d648db9cebb1c000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e01000001030e00ffea61659c02c4a38d5736767bec23ab8d2875ca2c6ae9b62bf37b2e18858cb394f9011564048bae1e4b83c9fc7eecb7635bc71e859155a30805bfc671d55f3364199e29253b878b59184050b781fcb05e16491b000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f01000001030f00ffea61659c02c4a38d5736767bec23ab8d287587c391ef9852490c8ee6da369527e3add67b95f18ea655a1b8febfb9a96172ed5fceee685c665ad6f564680e797a0d8686cc43822eb9f6d4be11f071ad5313851b000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001001000001031000ffea61659c02c4a38d5736767bec23ab8d2875446bf064a5dd466f835e52e230e6d416248d0857e8e7b91021715ace63f63f740ff07cf662f322e53e83020b1dd25a15cd501d9728ad5420eaae4ef1794bcbd81b000122df927e5298d841286e8f9661134ee764a13ae915d5a2735ef6b153592c08fd01aa6b96100001000038a7000000010000000000000000000000"},
																new Genesis {Zone = Zone.Testnet1,	Crypto = new EthereumCryptography(), Rounds = "0001000002030000ffea61659c02c4a38d5736767bec23ab8d28755fa1adabd7c2ec77529938a26038d40d0351959c087dc422d0b047c2081cf0e57c843831f6ee6b353c9aee47bb83f060f96722a9e15092739ba0eed55403d6411b000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000895acda618b9f0183c376fd31e6ca78e18717a881d960020e1b6c35f0b9df49ae0c604f20f6e39f4d055ed61baf9b021b178e213d44c1b1c918dc9ed7e417cf491c00000201090000a0dec5adc935364e2fcde50209000040bd8b5b936b6c005cf38e77111b17699b214c34d43dab5f9cea793d617cac8f0696206872ca64fb24faf717d3ce5dd3be6f2667a01f7a3debb1ead79eb19cf0e1b3ef14528e41631c00000201090000a0dec5adc935364e2fc6da0209000040bd8b5b936b6c00f0b6346c05052c2a1ea2a028e315da49ed06eff555b6b288db94c8cfde7eeb2720d6dbc9f335e456a684f2d2c57d96a206b065499d9c88257f5878e51f148a9b1c00000201090000a0dec5adc935364e2fd6ab0209000040bd8b5b936b6c002d05d09d6bdd1a0f67d8f3eb87ef0f3c9112eb1acb2980226729a2c99ec7d5f966516d3287f6b8061b1645bab1a41739b7fa9bf97f1cfd985bc901954c44b1041c00000201090000a0dec5adc935364e2fd6aa0209000040bd8b5b936b6c00edd1e6ae78e533744dd257b13a56c4384b8b03c7b26613bd7546759705719919248a99d3f153019cc2996d3869b46843124b307d992dd3285a8c5c40606b49e21b00000201090000a0dec5adc935364e2fd6a60209000040bd8b5b936b6c00ba07541515b84b58dc4cd95378019b511255c6f3ec41745c2128c52f9819ce0121395c080114a0ac8bd34bbd93c5ee9b8ffb29b862de13a18b987da37d87d3b31b00000201090000a0dec5adc935364e2fd6a10209000040bd8b5b936b6c000b1ab68bfa4ddf4754bd0bfc741a0aff13079aa62af528d450f1c23d455db5ff6f00ac1e1c951ab3a7b3e4e4b7f0f60ef565f2742f9c779c19483e4b4736f53c1b00000201090000a0dec5adc935364e2fcc640209000040bd8b5b936b6c0012f3e95186164878c1376a5caea0ba6a8a39ebd51f10bc9b25b0257e42ee460227242e791d55a0c5af3506bde7702c1f904ae1692204e3846935c33c3a6ac9b11c0000020402756f01000208000064a7b3b6e00d000100000038a7a3cb80ec769c632b7b3e43525547ecd1f5134209d039b6b90e792450dbe8d0aa771a450b479c161b13cc0d056b46558d78b427946ed87451efca7890c0e4a2787ae4bb7f5b5c1f15372718a180f922d41b4e2fcc6400000000000101000001030100ffea61659c02c4a38d5736767bec23ab8d28751d186d9c0f0d7171da0bc05fab424e35f4ff38f6c029fbb33f78daef83cf7d042b836f0a728f5536a2187394a721233a5c821c679bf3839d83cdbe9b20bcace21c0081d8c4bd75000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001f6b485a103d7d96a0c1a44ae6ce21779016c9bfb83de3fe1650c785a11b30c8315faf797da9cacadcc64dbc35a6986eb0246e258e6297254e07ac81d58ec89bb1b0101010502756f02554fff00000000000201000001030200ffea61659c02c4a38d5736767bec23ab8d2875a190c948a57868b77f322417c4f322fae5b0fbb5b1c622bd58381777258bbf021f77756102cd99828652651d4f3813b6ff85478083e1aa0a11d0495aa8eb61d71b000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000301000001030300ffea61659c02c4a38d5736767bec23ab8d2875fa4bd93346fb824c5e2bd14b7d2d538b76cf6395b0bfc4322c94df3e21b0c0652cecf1510b9257727b4cf67906c2152d6fe0978a9204b7fe4e66449c4feb573d1c000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000401000001030400ffea61659c02c4a38d5736767bec23ab8d2875e59fc17e2f56bdd8dddf9bcb906956f3f975408a7695947ea8e308974dc0c30f5666095714be85ab42277f741599500d54424ae02b30c1bb19975d28a1253f501b000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000501000001030500ffea61659c02c4a38d5736767bec23ab8d287568a231b362621b92de28f05c669471aa1f2fc7c5ca745487a6645f2ebb1e648632d655cd190787c2c2c08d18f3923e7a0432ce0d149092ab364f8469a73e73541c000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000601000001030600ffea61659c02c4a38d5736767bec23ab8d28757907791a0d187ffd3ae8958e7e9eb1cb0c1554a7eb014d79225565b04ebec2fa4fd183bfa78d0db28c3b0f94bc58c9c3570215cae3d63f3359493fd81f9a16fa1b000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000701000001030700ffea61659c02c4a38d5736767bec23ab8d2875537b9f73e964abac44eb5d955704cf04c61527d58168aad2c4ad1c75a499f8ef396338d488d23a40edc3ee92c0fbdc3e1ddc03812c6aac24a7a5dd645f646d431c000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000801000001030800ffea61659c02c4a38d5736767bec23ab8d2875599d41e8a42694135989e301e5debd7eb302a93f59ddddb23b75059da382dae50eb6e9af458bf0d71623750574b9981a81bab6531d0b2e955ed89809da08e4ed1b00010000000000000000000000000000000000000000000000000000000000000000000000000000000001000038a7a3cb80ec769c632b7b3e43525547ecd10000000000000000000901000001030900ffea61659c02c4a38d5736767bec23ab8d287573bbe354343b94867c78d742dc63b088812303281c2a7848e0a063b04a0436d975ccd1b4da17ce577c465c415facc0443c15b3ae67b90259b4417fbff53c07531b00010000000000000000000000000000000000000000000000000000000000000000000000000000000000000100fe929a68368c301a1906ed39016ee9be3d937b000000000000000a01000001030a00ffea61659c02c4a38d5736767bec23ab8d287566472f7c337c8a2badfd47ad838a3802d895c1d8aac8a5e30dc78083d8c5912d5a7c8ee1029b26c7f690f25220766295ae58fe29d604201170b2144f38811a721c000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000b01000001030b00ffea61659c02c4a38d5736767bec23ab8d287517a321a967e57c1d05dc635ae88ace4c63d4de96626afb50b6230dcdae6154955c2a186886086d1a88e00a432d080020a0f5e513cfb1c1584f2c58646308e66e1b000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c01000001030c00ffea61659c02c4a38d5736767bec23ab8d2875fcf4e4a7a5dac9a31a2c9c5938d924c7085fa09772b9567051efb2f3b210692c263417202bb6adf0f1ec6869735c53073984ce47264cc66c94337998a2678a931c000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000d01000001030d00ffea61659c02c4a38d5736767bec23ab8d287511d154f93c59283954adf971c244cb6dbd68e7a4c3d5c1fc24e62170e2edca2638d0a75dabfeeed6d9851a52ea59fac62be0f0b3abb48cf6b33184847cda5fd91b000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e01000001030e00ffea61659c02c4a38d5736767bec23ab8d2875bcf3c2b44d60f27a212f97e41b70e874e54630e5c12114caa2e94070fec0467a272abffdd704c4345bee4d485e881fb732baa9d0ef8ab9e99378d41a2531eb291c000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f01000001030f00ffea61659c02c4a38d5736767bec23ab8d2875546239868668e789176f6bf5a34ec90e41ef6e4eae359e963872b0ed9f2358c25e5c5576d00dc638395d28e6b9053cd4b37f685d922de0b30414248130f5ead11b000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001001000001031000ffea61659c02c4a38d5736767bec23ab8d28751ea77332e14a8e6d04d891eed600a17a239349d061d3e9a378cc05c449d1645c207781e059e0e3c91e93a406ce21617c2c618fdb546b55bbcdf44c6217a201801b000190c8b461fc5a4cdafc78cefadf1cec7750fdc8c617d66e26e31301a621fed7e20110f4f2780001000038a7000000010000000000000000000000"},
															};

		readonly byte[]										LastRoundKey	= new byte[] {1};
		readonly byte[]										WeiSpentKey		= new byte[] {2};
		readonly byte[]										FactorKey		= new byte[] {3};
		readonly byte[]										EmissionKey		= new byte[] {4};

		public Round										LastConfirmedRound	=> Rounds.FirstOrDefault(i => i.Confirmed) ?? LastSavedRound;
		public Round										LastVotedRound		=> Rounds.FirstOrDefault(i => i.Voted) ?? LastConfirmedRound;
		public Round										LastNonEmptyRound	=> Rounds.FirstOrDefault(i => i.Blocks.Any()) ?? LastConfirmedRound;
		public Round										LastPayloadRound	=> Rounds.FirstOrDefault(i => i.Blocks.Any(i => i is Payload)) ?? LastConfirmedRound;
		
		Round LastSavedRound
		{
			get
			{
				var d = Database.Get(LastRoundKey);

				if(d == null)
					return null;
				else
					return FindRound(BitConverter.ToInt32(d));
			}
		}

		public BigInteger									LastSavedWeiSpent	=> new BigInteger(Database.Get(WeiSpentKey));
		public Coin											LastSavedFactor		=> new Coin(Database.Get(FactorKey));
		public Coin											LastSavedEmission	=> new Coin(Database.Get(EmissionKey));

		public ColumnFamilyHandle							AccountsFamily	=> Database.GetColumnFamily(nameof(Accounts));
		public ColumnFamilyHandle							AuthorsFamily	=> Database.GetColumnFamily(nameof(Authors));
		public ColumnFamilyHandle							ProductsFamily	=> Database.GetColumnFamily(nameof(Products));
		public ColumnFamilyHandle							RoundsFamily	=> Database.GetColumnFamily(nameof(Rounds));
		public ColumnFamilyHandle							MembersFamily	=> Database.GetColumnFamily(nameof(Members));
		public ColumnFamilyHandle							FundablesFamily	=> Database.GetColumnFamily(nameof(Fundables));

		public static int									GetValidityPeriod(int rid) => rid + Pitch;

		public Roundchain(Settings settings, Log log, INas nas, Vault vault, RocksDb database)
		{
			Settings = settings;
			Log = log;
			Database = database;

			///GenerateFathers(256);

			Accounts = new AccountTable(this, AccountsFamily);
			Authors = new AuthorTable(this, AuthorsFamily);
			Products = new ProductTable(this, ProductsFamily);

			if(LastSavedRound == null)
			{
				if(settings.Dev.GenerateGenesis)
				{
					var ips = nas.GetInitials(settings.Zone).ToArray();

					var s = new MemoryStream();
					var w = new BinaryWriter(s);

					var gen = vault.GetFather(GenAccount);
					var org = vault.GetFather(OrgAccount);

					//long datebase = 1900;

					void write(int rid)
					{
						var r = FindRound(rid);
						r.Voted = true;
						r.Write(w);
					}

					var b0 = new Payload(this)
							{
								RoundId		= 0,
								TimeDelta	= 0,
								Reference	= RoundReference.Empty,
							};


					var jr = new JoinRequest(this)
								{
									RoundId		= 0,
									IP			= ips[0]
								};

					var t = new Transaction(Settings, org, 0);
					t.AddOperation(new AuthorBid(org, "uo", 0));
					t.AddOperation(new Emission(org, Web3.Convert.ToWei(1, UnitConversion.EthUnit.Ether), 0));
					t.Sign(gen, 0);
					b0.AddNext(t);
						
					for(int i=0; i<Fathers.Length; i++)
					{
						var f = vault.GetFather(Fathers[i]);
					
						t = new Transaction(Settings, f, 0);
						t.AddOperation(new CandidacyDeclaration(f, new Coin(1000), ips[i]));
						t.AddOperation(new Emission(f, Web3.Convert.ToWei(settings.Zone == Zone.Mainnet ? 2 : 2_000, UnitConversion.EthUnit.Ether), 0));
						t.Sign(gen, 0);

						b0.AddNext(t);
					}
		
					b0.Sign(gen);
					Add(b0, false);

					jr.Sign(vault.GetFather(Fathers[0]));
					Add(jr, false);

					write(0);
					
					for(int i = 1; i < Pitch; i++)
					{
						var b = new Payload(this)
								{
									RoundId		= i,
									TimeDelta	= i == 1 ? ((long)TimeSpan.FromDays(365).TotalMilliseconds + 1) : 1,  //new AdmsTime(AdmsTime.FromYears(datebase + i).Ticks + 1),
									Reference	= RoundReference.Empty,
								};

						if(i == 1)
						{
							t = new Transaction(Settings, org, 1);
							t.AddOperation(new AuthorRegistration(org, "uo", "UO", 255));
							t.Sign(gen, i);
							b.AddNext(t);
						}
							
						b.Sign(gen);
						Add(b, false);

						write(i);
					}

					for(int i = Pitch; i <= LastGenesisRound; i++)
					{
						var p = GetRound(i - Pitch);

						var b = new Payload(this)
								{
									RoundId		= i,
									TimeDelta	= 1,  //new AdmsTime(AdmsTime.FromYears(datebase + i).Ticks + 1),
									Reference	= Refer(p)
								};
	
						if(i == Pitch)
							b.Joiners.Add(Fathers[0]);

						if(i == Pitch + 1)
							b.FundableAssignments.Add(OrgAccount);

						b.Sign(gen);
						Add(b, false);

						write(i);
					}
					
					var g = s.ToArray().ToHex();
					
					if(g != Genesises.Find(i => i.Zone == Settings.Zone && i.Crypto.GetType() == Cryptography.Current.GetType()).Rounds)
						throw new IntegrityException("Genesis update needed");

					Rounds.Clear();
				}

				var rd = new BinaryReader(new MemoryStream(Genesises.Find(i => i.Zone == Settings.Zone && i.Crypto.GetType() == Cryptography.Current.GetType()).Rounds.HexToByteArray()));
	
				for(int i = 0; i < Pitch*2 + 1; i++)
				{
					var r = new Round(this);
					r.Read(rd);
	
					Rounds.Insert(0, r);
			
					if(i == Pitch)
					{
						r.ConfirmedJoiners.Add(Fathers[0]);
					}

					Confirm(r);
				}
			}
			else
			{
				using(var i = Database.NewIterator(MembersFamily))
				{
					for(i.SeekToFirst(); i.Valid(); i.Next())
					{
						var a = new Account();
						a.Read(new BinaryReader(new MemoryStream(i.Key())));

						var cd = Accounts.FindLastOperation<CandidacyDeclaration>(a, i => i.Result == OperationResult.OK);

						Members.Add(new Peer {Generator = a, IP = cd.IP, JoinedAt = cd.Transaction.Payload.RoundId + Pitch*2});
					}
				}

				using(var i = Database.NewIterator(FundablesFamily))
				{
					for(i.SeekToFirst(); i.Valid(); i.Next())
					{
						Fundables.Add(new Account(i.Key()));
					}
				}
			}
		}

		public string GenerateFathers(int n)
		{
 			var accs = new EthECKey[n];
 
 			var tasks = new Task[n];
 
 			for(int i=0; i<n; i++)
 			{
 				tasks[i] =	Task.Run(() =>
 							{
 								while(accs.Contains(null))
 								{
 									var k = EthECKey.GenerateKey();
 	
 									var pub = Sha3Keccack.Current.CalculateHash(k.GetPubKeyNoPrefix());
 					
 									if(pub[12] == 0x00)
 									{
 										var i = pub[13];
 		
 										if(i < n && accs[i] == null)
 										{
 											accs[i] = k;

											byte[] array2 = new byte[pub.Length - 12];
											Array.Copy(pub, 12, array2, 0, pub.Length - 12);

											new PrivateAccount(k).Save(Path.Join(Settings.Secret.Fathers, "0x" + array2.ToHex()), Settings.Secret.Password);
 										}
 									}
 								}
 							});
 			}
 
 			Task.WaitAll(tasks);
 
 			return string.Join(Environment.NewLine, accs.Select(i => i.GetPrivateKey()));
		}

		public void Add(Block b, bool execute = true)
		{
			var r = GetRound(b.RoundId);

			b.Round = r;
			r.Blocks.Add(b);

			if(execute)
			{
				if(b is JoinRequest jr)
				{
					jr.Declaration = Accounts.FindLastOperation<CandidacyDeclaration>(jr.Member);
				}
				else if(b is Payload)
				{
					for(int i = r.Id; i <= LastPayloadRound.Id; i++)
					{
						var ir = GetRound(i);
						
						if(ir.Majority.Any())
							Execute(ir, ir.Majority.OfType<Payload>(), null);
						else
							break;
					}
				}

				if(b is Vote v && r.FirstArrivalTime == DateTime.MaxValue)
				{
					r.FirstArrivalTime = DateTime.UtcNow;
				} 
			}

			BlockAdded?.Invoke(b);
		}

		public void Add(IEnumerable<Block> bb)
		{
			foreach(var i in bb)
			{
				Add(i);
			}
		}

		public bool Verify(Block b)
		{
			if(b.RoundId <= LastConfirmedRound.Id)
				return false;

			var r = FindRound(b.RoundId);
	
			if(r != null && r.Blocks.Any(i => i.Signature.SequenceEqual(b.Signature)))
				return false;
		
			return b.Valid;
		}

		public Round GetRound(int rid)
		{
			var r = FindRound(rid);

			if(r == null)
			{	
				r = new Round(this) {Id = rid};
				r.LastAccessed = DateTime.UtcNow;
				Rounds.Add(r);
				Rounds = Rounds.OrderByDescending(i => i.Id).ToList();
			}

			return r;
		}

		public Round FindRound(int rid)
		{
			foreach(var i in Rounds)
				if(i.Id == rid)
				{
					i.LastAccessed = DateTime.UtcNow;
					return i;
				}

			if(LoadedRounds.ContainsKey(rid))
			{
				var r = LoadedRounds[rid];
				r.LastAccessed = DateTime.UtcNow;
				return r;
			}

			var d = Database.Get(BitConverter.GetBytes(rid), RoundsFamily);

			if(d != null)
			{
				var r = new Round(this);
				r.Id			= rid; 
				r.Voted			= true; 
				r.Confirmed		= true;
				r.LastAccessed	= DateTime.UtcNow;

				r.Load(new BinaryReader(new MemoryStream(d)));
	
				LoadedRounds[r.Id] = r;
				Recycle();
				return r;
			}
			else
				return null;
		}

		void Recycle()
		{
			//if(LoadedRounds.Count > CacheLimit)
			//{
			//	foreach(var i in LoadedRounds.OrderByDescending(i => i.LastAccessed).Skip(CacheLimit))
			//	{
			//		LoadedRounds.Remove(i);
			//	}
			//}
		}

		public IEnumerable<Account> FindFundables(Round r)
		{
			return Fundables;
		}

		//public Round FindRound(Func<Round, bool> f, int maxrid = int.MaxValue, int depth = int.MaxValue)
		//{
		//	foreach(var r in Rounds.Where(i => maxrid - depth < i.Id && i.Id <= maxrid))
		//		if(f(r))
		//			return r;
		//
		//	
		//	for
		//		foreach(var r in e.Rounds.Where(i => i.Id <= maxrid))
		//			if(f(r))
		//				return r;
		//
		//	return null;
		//}

		public IEnumerable<Peer> VotersFor(Round r)
		{
			return Members.Where(i => i.JoinedAt < r.Id);
		}

		public IEnumerable<JoinRequest> JoinersFor(Round round)
		{
			return FindRound(round.ParentId).JoinRequests.Where(jr =>	{
																			var cd = Accounts.FindLastOperation<CandidacyDeclaration>(jr.Member, o => o.Successful, rp: r => r.Confirmed && r.Id < jr.RoundId);
																			return cd != null;
																		})
															.OrderByDescending(jr => Accounts.FindLastOperation<CandidacyDeclaration>(jr.Member, o => o.Successful, rp: r => r.Confirmed && r.Id < jr.RoundId).Bail);
		}

		public IEnumerable<Account> ProposeJoiners(Round round)
		{
			var joiners = JoinersFor(round);

			var n = Members.Count < MembersMax ? MembersMax - Members.Count : MembersRotation;

			return joiners.Take(n).Select(i => i.Member);
		}

		public IEnumerable<Account> ProposeLeavers(Round round, Account generator)
		{
			var joiners = JoinersFor(round);

			var o = VotersFor(round).Where(i =>	i.JoinedAt < round.ParentId &&
												Rounds.Count(r =>	round.ParentId <= r.Id && r.Id < round.Id &&					/// in previous Pitch number of rounds
																	r.Blocks.Any(b => b.Member == i.Generator)) < Pitch * 2/3 &&	/// sent less than 2/3 of required blocks
												!Enumerable.Range(round.Id - Pitch + 1, Pitch - 1).Select(i => FindRound(i)).Any(r => r.Votes.Any(v => v.Member == generator && v.Leavers.Contains(i.Generator))) /// not yet reported in prev [Pitch-1] rounds
											)	
												
									.Select(i => i.Generator);

			if(!o.Any() && Members.Count == MembersMax && joiners.Any())
				return Members.OrderByDescending(i => i.JoinedAt).Take(joiners.Take(MembersRotation).Count()).Select(i => i.Generator);
			else
				return o;
		}

		public bool QuorumReached(Round r)
		{
			var members = VotersFor(r).Select(i => i.Generator);

			return r.Unique.Count(i => members.Contains(i.Member)) >= Math.Max(1, members.Count() * 2/3);
		}

		public bool QuorumFailed(Round r)
		{
			var max = VotersFor(r).Select(i => i.Generator);

			return r.Unique.Count() >= Math.Max(1, max.Count() * 2/3) && r.Majority.Count() + (max.Count() - r.Unique.Count()) < Math.Max(1, max.Count() * 2/3);
		}

		public ChainTime CalculateTime(Round round, IEnumerable<Payload> votes)
		{
 			if(round.Id == 0)
 			{
 				return round.Time;
 			}

 			if(!votes.Any())
 			{
				return round.Previous.Time + new ChainTime(1);
			}

			///var t = 0L;
			///var n = 0;
			///
			///for(int i = Math.Max(0, round.Id - Pitch + 1); i <= round.Id; i++)
			///{
			///	var r = FindRound(i);
			///	t += r.Payloads.Sum(i => i.Time.Ticks);
			///	n += r.Payloads.Count();
			///}
			///
			///t /= n;

			return round.Previous.Time + new ChainTime(votes.Sum(i => i.TimeDelta)/votes.Count());
		}

		public IEnumerable<Transaction> CollectValidTransactions(IEnumerable<Transaction> txs, Round round)
		{
			txs = txs.Where(i => round.Id <= i.RoundMax && IsSequential(i, round.Id));

			if(txs.Any())
			{
				var p = new Payload(this);
				p.Member	= Account.Zero;
				p.Time		= DateTime.UtcNow;
				p.TimeDelta	= 1;
					
				foreach(var i in txs)
				{
					p.AddNext(i);
				}
				
 				Execute(round, new Payload[] {p}, null);
 	
 				txs = txs.Where(t => t.Successful);
			}

			return txs;
		}

		public bool IsSequential(Transaction transaction, int ridmax)
		{
			var prev = Accounts.FindLastTransaction(transaction.Signer, t => t.Successful, null, r => r.Id < ridmax);

			if(transaction.Id == 0 && prev == null)
				return true;

			if(transaction.Id == 0 && prev != null || transaction.Id != 0 && prev != null && prev.Id != transaction.Id - 1)
				return false;

			/// STRICT: return prev != null && (prev.Payload.Confirmed || prev.Payload.Transactions.All(i => IsSequential(i, i.Payload.RoundId))); /// All transactions in a block containing 'prev' one must also be sequential
			return prev.Payload.Confirmed || IsSequential(prev, prev.Payload.RoundId);
		}

		public RoundReference Refer(Round round)
		{
			if(round.Id < Pitch)
				return RoundReference.Empty;

			byte [] hashpitch(Round last, IEnumerable<Payload> ps) /// hash referred round and previous [Pitch-1] ones
			{
				var s = new MemoryStream();
				var w = new BinaryWriter(s);

				for(int i = Math.Max(0, last.Id - Roundchain.Pitch + 1); i < last.Id; i++) /// previous [Pitch-1] rounds
				{
					var r = FindRound(i);
	
					if(r.Id > LastGenesisRound && !r.Confirmed)
					{
						return null;
					}
	
					w.Write(i < Pitch ? Cryptography.ZeroHash : r.Hash);
				}

				foreach(var p in ps) /// referred round itself
				{
					p.Seal(w);
				}

				return Cryptography.Current.Hash(s.ToArray());
			}

			var p = round.Parent;
			var h = hashpitch(p, p.Id <= LastGenesisRound ? p.Payloads : p.ConfirmedPayloads);	/// get candidates' its own referance hash, [parent.Id - Pitch + 1 .. parent.Id]
																								/// must always return non-null cause all of rounds must be already confirmed

			var payloads = round.Unique.OfType<Payload>().Where(i => i.Reference.Hash.SequenceEqual(round.ParentId < Pitch ? RoundReference.Empty.Hash : h));	/// refers to correct confirmed [Pitch] number of parent rounds
			
			if(payloads.Any())
				payloads = payloads.GroupBy(i => i.Reference).Aggregate((i, j) => i.Count() > j.Count() ? i : j); /// take majority if any
	
			payloads = payloads.OrderBy(i => i.OrderingKey, new BytesComparer());

			h = hashpitch(round, payloads); /// now get the hash to this round and [Pitch-1] of previous

			if(h == null) 
				return null; /// some of previous [Pitch-1] rounds is not confirmed

			var rr = new RoundReference();

			rr.Hash					= h;
			rr.Payloads				= payloads.							Select(i => i.Prefix).ToList();
			rr.Leavers				= round.ElectedLeavers.				Select(i => i.Prefix).ToList();
			rr.Joiners				= round.ElectedJoiners.				Select(i => i.Prefix).OrderBy(i => i, new BytesComparer()).Take(rr.Leavers.Count + NewMembersPerRoundMax).ToList();
			rr.Violators			= round.ElectedViolators.			Select(i => i.Prefix).ToList();
			rr.FundableAssignments	= round.ElectedFundableAssignments.	Select(i => i.Prefix).ToList();
			rr.FundableRevocations	= round.ElectedFundableRevocations.	Select(i => i.Prefix).ToList();
			//rr.Propositions			= round.ElectedPropositions.		Select(i => i.Prefix).ToList();
			rr.Time					= CalculateTime(round, payloads);

			return rr;
		}

		public Coin CalculateFee(Round r, Transaction t)
		{
			return FeePerByte * ((Emission.FactorEnd - r.Factor) / Emission.FactorEnd) * t.CalculatePaidSize();
		}

		public void Execute(Round round, IEnumerable<Payload> payloads, IEnumerable<Account> blockforkers)
		{
			var prev = round.Previous;
				
			if(round.Id != 0 && prev == null)
				return;

			var txviolators = new List<Account>(); 

			round.Members			= Members.ToList();
			round.Fundables			= FindFundables(round).ToList();
			round.ExecutingPayloads = payloads;
			round.Time				= CalculateTime(round, payloads);

			void execute(bool collectviolators)
			{
				round.Accounts.Clear();
				round.Authors.Clear();
				round.Products.Clear();
				round.AffectedReleases.Clear();

				round.Emission	= round.Id == 0 ? 0						: (prev == LastSavedRound ?	LastSavedEmission	: prev.Emission);
				round.WeiSpent	= round.Id == 0 ? 0						: (prev == LastSavedRound ?	LastSavedWeiSpent	: prev.WeiSpent);
				round.Factor	= round.Id == 0 ? Emission.FactorStart	: (prev == LastSavedRound ?	LastSavedFactor		: prev.Factor);

				foreach(var b in round.ExecutingPayloads.Reverse())
				{
					foreach(var t in b.Transactions.AsEnumerable().Reverse())
					{
						if(collectviolators || !txviolators.Contains(t.Signer)) /// Reject all txviolators
						{
							t.Successful = true;
							round.GetAccount(t.Signer).Transactions.Add(round.Id);

							foreach(var o in t.Operations.AsEnumerable().Reverse())
							{
								round.CurrentOperation = o;
								o.Result = o.Execute(this, round);
							}
						}
						else
						{
							t.Successful = false;

							foreach(var i in t.Operations)
								i.Result = OperationResult.Rejected;
						}

						var final = round.GetAccount(t.Signer).Balance;
						var fee = CalculateFee(round, t);

						if(final >= fee)
						{
							round.GetAccount(t.Signer).Balance -= fee;
							round.Distribute(fee, new Account[] {b.Member}, 9, round.Fundables, 1); /// this way we prevent a member from sending his own transactions using his own blocks for free, this could be used for block flooding 
						}
						else
						{
							if(collectviolators)
							{
								txviolators.Add(t.Signer); /// collect tsx if its final balance is not enough to pay the 'fee'
							} 
							else
							{
								/// debit from tx signer

								if(final > 0)
								{
									round.GetAccount(t.Signer).Balance = 0;
									round.Distribute(final, round.Members.Select(i => i.Generator), 1, round.Fundables, 1);
								}

								//round.GetAccount(b.Member).Bail -= fee;
								//round.DistributeFunds(fee);
							}
						}
					}
				}

				round.CurrentOperation = null;
			}

			execute(true);

			if(round.Id > LastGenesisRound)
			{
				var txs = round.ExecutingPayloads.SelectMany(i => i.Transactions);
				
				txviolators.AddRange(txs.Where(t => { 
														if(round.ExecutingPayloads.Count(b => b.Transactions.Any(i => i.Signer == t.Signer)) > 1)			/// CHECK: presence in more than 1 block in current round
															return true;
																													
														var pre = Accounts.FindLastTransaction(t.Signer, t => t.Successful, null, i => i.Id < round.Id);	/// CHECK: any non-sequential tx in previous rounds? ignoring all previous invalid tx's
												
														if(pre == null ? t.Id != 0 : pre.Id + 1 != t.Id)
															return true;
														else
															return false;
													})
													.Select(i => i.Signer).Distinct());

				if(txviolators.Any())
				{
					execute(false);
				}

				var penalty = Coin.Zero;

				if(blockforkers != null && blockforkers.Any())
				{
					foreach(var f in blockforkers)
					{
						penalty += Accounts.FindLastOperation<CandidacyDeclaration>(f, t => t.Successful, o => o.Successful, null, i => i.Id < round.Id).Bail;
						round.GetAccount(f).BailStatus = BailStatus.Siezed;
					}

					round.Distribute(penalty, round.Members.Where(i => !blockforkers.Contains(i.Generator)).Select(i => i.Generator), 1, round.Fundables, 1);
				}
			}
		}

		public void Confirm(Round round)
		{
			if(round.Id > 0 && LastConfirmedRound.Id + 1 != round.Id)
				throw new IntegrityException("LastConfirmedRound.Id + 1 == round.Id");

			List<T>	confirm<T>(IEnumerable<byte[]> prefixes, Func<Vote, IEnumerable<T>> get, Func<T, byte[]> getprefix)
							{
								var o = prefixes.Select(v => round.Unique.SelectMany(i => get(i)).FirstOrDefault(i => getprefix(i).SequenceEqual(v)));

								if(o.Contains(default(T)))
									throw new ConfirmationException("Can't confirm, some references not found", round);
								else 
									return o.ToList();
							}

			/// check we have all payload blocks
		
			if(round.Id > LastGenesisRound)
			{
				foreach(var i in round.Payloads)
					i.Confirmed = false;

				var child = FindRound(round.Id + Pitch);
				var rf = child.Majority.First().Reference;
 	
				foreach(var pf in rf.Payloads)
				{
					var b = round.Unique.FirstOrDefault(i => pf.SequenceEqual(i.Prefix));

					if(b != null)
						b.Confirmed = true;
					else
						return; // Some block(s) not present
				}

				round.ConfirmedJoiners				= confirm(rf.Joiners, i => i.Joiners, i => i.Prefix).Where(i =>{ 
																													var d = Accounts.FindLastOperation<CandidacyDeclaration>(i, o => o.Successful, null, null, r => r.Id <= round.Id);
																													return d != null && d.Transaction.Payload.RoundId <= round.Id - Pitch*2 && d.Bail >= (Settings.Dev != null && Settings.Dev.DisableBailMin ? 0 : BailMin); 
																												})
																										.ToList(); /// round.Id - Pitch*2 means to not join earlier than 2 Pitches after declaration, and not redeclare after a join is requested
				round.ConfirmedLeavers				= confirm(rf.Leavers,				i => i.Leavers,				i => i.Prefix);
				round.ConfirmedViolators			= confirm(rf.Violators,				i => i.Violators,			i => i.Prefix);
				round.ConfirmedFundableAssignments	= confirm(rf.FundableAssignments,	i => i.FundableAssignments, i => i.Prefix);
				round.ConfirmedFundableRevocations	= confirm(rf.FundableRevocations,	i => i.FundableRevocations, i => i.Prefix);
				//round.ConfirmedPropositions			= confirm(rf.Propositions,			i => i.Propositions,		i => i.Prefix);
				round.Time							= rf.Time;
			}
			else
			{
				foreach(var i in round.Payloads)
					i.Confirmed = true;

				if(round.Id > 0)
					round.Time = CalculateTime(round, round.Unique.OfType<Payload>());
			}

			round.Confirmed = true;

			Seal(round);
		}

		public void Seal(Round round)
		{
			Execute(round, round.ConfirmedPayloads, round.ConfirmedViolators);

			round.Seal();

			Members.AddRange(round.ConfirmedJoiners.Select(i =>	{
																	var d = Accounts.FindLastOperation<CandidacyDeclaration>(i,  o => o.Successful, null, null, r => r.Id < round.Id);
																	return new Peer {Generator = i, IP = d.IP, JoinedAt = round.Id + Pitch};
																}));

			Members.RemoveAll(i => round.AnyOperation(o => o is CandidacyDeclaration d && d.Signer == i.Generator && o.Result == OperationResult.OK));  /// CandidacyDeclaration cancels membership
			Members.RemoveAll(i => round.Accounts.ContainsKey(i.Generator) && round.Accounts[i.Generator].Bail < (Settings.Dev.DisableBailMin ? 0 : BailMin));  /// if Bail has exhausted due to penalties (CURRENTY NOT APPLICABLE, penalties are disabled)
			Members.RemoveAll(i => round.ConfirmedLeavers.Contains(i.Generator));
			Members.RemoveAll(i => round.ConfirmedViolators.Contains(i.Generator));

			//var affected = new HashSet<Round>{round};

			//foreach(var i in round.ConfirmedPropositions)
			//{
			//	foreach(var m in i.Messages)
			//	{
			//		if(m is ReleaseDeclaration d)
			//		{
			//			var r = FindProduct(d.Address, round.Id - 1)?.Releases.FirstOrDefault(i => i.Platform == d.Address.Platform && i.Channel == d.Channel);
			//		
			//			if(r != null && r.Version < d.Address.Version)
			//			{
			//				var rn = FindRound(r.Rid);
			//				
			//				var prev = rn.Releases.Find(i => i.Address.Author == d.Address.Author && 
			//												 i.Address.Product == d.Address.Product && 
			//												 i.Address.Platform == d.Address.Platform && 
			//												 i.Channel == d.Channel);
			//
			//				if(prev != null)
			//				{
			//					rn.Releases.Remove(prev);
			//					affected.Add(rn);
			//				}
			//			}
			//		}
			//	}
			//}


			if(round.Factor == Emission.FactorEnd) /// reorganization only after emission is over
			{
				Fundables.AddRange(round.ConfirmedFundableAssignments);
				Fundables.RemoveAll(i => round.ConfirmedFundableRevocations.Contains(i));
			}

			if(round.Id - Rounds.Last().Id > Pitch + Pitch + 1) /// keep last [Pitch] sealed rounds cause [LastSealed - Pitch] round may contain JoinRequests that are needed if a node is joining
			{
				var r = Rounds.Last();

				using(var b = new WriteBatch())
				{
					b.Put(LastRoundKey, BitConverter.GetBytes(r.Id));
					b.Put(WeiSpentKey,	r.WeiSpent.ToByteArray());
					b.Put(FactorKey,	r.Factor.Attos.ToByteArray());
					b.Put(EmissionKey,	r.Emission.Attos.ToByteArray());

					Accounts.Save(b, r.Accounts.Values);
					Authors.Save(b, r/*r.Unique.SelectMany(i => i.Messages.SelectMany(i => i.Operations).OfType<ReleaseDeclaration>())*/);
					Products.Save(b, r.Products.Values);


					foreach(var i in r.ConfirmedJoiners)
						b.Put(i, new byte[0], MembersFamily);

					foreach(var i in r.ConfirmedLeavers)
						b.Delete(i, MembersFamily);

					foreach(var i in r.ConfirmedFundableAssignments)
						b.Put(i, new byte[0], FundablesFamily);

					foreach(var i in r.ConfirmedFundableRevocations)
						b.Delete(i, FundablesFamily);

					foreach(var i in r.AffectedReleases)
					{
						i.Key.Releases = i.Value;

						var s = new MemoryStream();
						var w = new BinaryWriter(s);
						
						i.Key.Save(w);
						b.Put(BitConverter.GetBytes(i.Key.Id), s.ToArray(), RoundsFamily);
					}

					if(!r.AffectedReleases.ContainsKey(r)) /// if not saved above
					{
						var s = new MemoryStream();
						var w = new BinaryWriter(s);
						
						r.Save(w);
						b.Put(BitConverter.GetBytes(r.Id), s.ToArray(), RoundsFamily);
					}

					Database.Write(b);
				}
				
				Rounds.Remove(r);
				
				/// to save RAM
				r.Members = null;
				r.Fundables = null;
				r.Accounts = null;
				r.Authors = null;
				r.Products = null;
				r.CurrentOperation = null;
				r.Blocks.RemoveAll(i => !i.Confirmed);

				r.LastAccessed	= DateTime.UtcNow;
				LoadedRounds[r.Id] = r;
				Recycle();
			}
		}

		public IEnumerable<AuthorEntry> FindAuthors(Account account, Round executing)
		{
			var o = new List<AuthorEntry>();

			foreach(var r in Rounds.Where(i => i.Id <= executing.Id))
				foreach(var a in r.Authors)
				{
					var auth = Authors.Find(a.Key, executing.Id);

					var lt = auth.FindTransfer(executing);
					var lr = auth.FindRegistration(executing);

					if(lr != null && (lt == null ? lr.Signer : lt.To) == account && !o.Any(i => i.Name == a.Value.Name))
					{	
						o.Add(a.Value);
						yield return a.Value; 
					}
				}

			var e = Accounts.FindEntry(account);

			if(e != null)
				foreach(var a in e.Authors.Select(i => Authors.FindEntry(i)))
					if((a.LastTransfer != -1 ? a.LastTransfer : a.LastRegistration) <= executing.Id)
					{
						if(!o.Any(i => i.Name == a.Name))
						{	
							o.Add(a);
							yield return a;
						}
					}
					else
						throw new IntegrityException("maxrid works inside pool only");
		}

		public ProductEntry FindProduct(ProductAddress authorproduct, int ridmax)
		{
			foreach(var r in Rounds.Where(i => i.Id <= ridmax))
				if(r.Products.ContainsKey(authorproduct))
					return r.Products[authorproduct];

			var e = Products.FindEntry(authorproduct);

			if(e != null && (e.LastRegistration > ridmax))
				throw new IntegrityException("maxrid works inside pool only");

			return e;
		}

		public Transaction FindLastPoolTransaction(Func<Transaction, bool> transaction_predicate, Func<Payload, bool> payload_predicate = null, Func<Round, bool> round_predicate = null)
		{
			foreach(var r in round_predicate == null ? Rounds : Rounds.Where(round_predicate))
				foreach(var b in payload_predicate == null ? r.Payloads : r.Payloads.Where(payload_predicate))
					foreach(var t in b.Transactions)
						if(transaction_predicate == null || transaction_predicate(t))
							return t;

			return null;
		}

		public IEnumerable<Transaction> FindLastPoolTransactions(Func<Transaction, bool> transaction_predicate, Func<Payload, bool> payload_predicate = null, Func<Round, bool> round_predicate = null)
		{
			foreach(var r in round_predicate == null ? Rounds : Rounds.Where(round_predicate))
				foreach(var b in payload_predicate == null ? r.Payloads : r.Payloads.Where(payload_predicate))
					foreach(var t in transaction_predicate == null ? b.Transactions : b.Transactions.Where(transaction_predicate))
						yield return t;
		}

		public O FindLastPoolOperation<O>(Func<O, bool> op = null, Func<Transaction, bool> tp = null, Func<Payload, bool> pp = null, Func<Round, bool> rp = null)
		{
			var ops = FindLastPoolTransactions(tp, pp, rp).SelectMany(i => i.Operations.OfType<O>());
			return op == null ? ops.FirstOrDefault() : ops.FirstOrDefault(op);
		}

		IEnumerable<O> FindLastPoolOperations<O>(Func<O, bool> op = null, Func<Transaction, bool> tp = null, Func<Payload, bool> pp = null, Func<Round, bool> rp = null)
		{
			var ops = FindLastPoolTransactions(tp, pp, rp).SelectMany(i => i.Operations.OfType<O>());
			return op == null ? ops : ops.Where(op);
		}

		public Block FindLastBlock(Func<Block, bool> f, int maxrid = int.MaxValue)
		{
			foreach(var r in Rounds.Where(i => i.Id <= maxrid))
				foreach(var b in r.Blocks)
					if(f(b))
						return b;

			return null;
		}

		public IEnumerable<Block> FindLastBlocks(Func<Block, bool> f, int maxrid = int.MaxValue)
		{
			foreach(var r in Rounds.Where(i => i.Id <= maxrid))
				foreach(var b in r.Blocks)
					if(f(b))
						yield return b;
		}

		public IEnumerable<ReleaseManifest> FindReleases(string author, string product, Func<ReleaseManifest, bool> f, int maxrid = int.MaxValue)
		{
			throw new NotImplementedException();

///			return FindLastPoolOperations<Release>(i => i.Author == author && i.Product == product && f(i), rp: r => r.Id <= maxrid).Union(Products.FindReleases(author, product, f));
		}
		
		public AccountInfo GetAccountInfo(Account account, bool confirmed)
		{
			var roundmax = confirmed ? LastConfirmedRound : LastNonEmptyRound;

			var a = Accounts.Find(account, roundmax.Id);

			if(a != null)
			{
				var i = new AccountInfo();

				var t = Accounts.FindLastTransaction(account, i => i.Successful);

				i.Balance			= a.Balance;
				i.LastTransactionId	= t == null ? -1 : t.Id;
				i.Authors			= a.Authors;
				i.Operations		= Accounts.FindLastOperations<Operation>(account).Take(10).Reverse().Select(i => new AccountOperationInfo(i)).ToList();

				return i;
			}

			return null;
		}

		public AuthorInfo GetAuthorInfo(string author, bool confirmed)
		{
			var roundmax = confirmed ? LastConfirmedRound : LastNonEmptyRound;

			var a = Authors.Find(author, roundmax.Id);

			if(a != null)
			{
				var i = new AuthorInfo();

				var f = a.FindFirstBid(roundmax);
				var l = a.FindLastBid(roundmax);
				var r = a.FindRegistration(roundmax);
				var t = a.FindTransfer(roundmax);

				i.Name				= author;
				i.Owner				= a.FindOwner(roundmax);
				i.FirstBid			= f != null ? new AuthorBidInfo(f) : null;
				i.LastBid			= l != null ? new AuthorBidInfo(l) : null;
				i.LastRegistration	= r != null ? new AuthorRegistrationInfo(r) : null;
				i.LastTransfer		= t != null ? new AuthorTransferInfo(t) : null;
				i.Products			= a.Products;
	
				return i;
			}

			return null;
		}
		
		public ReleaseAddress QueryRelease(ReleaseQuery query, bool confirmed)
		{
			var roundmax = confirmed ? LastConfirmedRound : LastNonEmptyRound;

			var p = Products.Find(query, roundmax.Id);

			if(p != null)
			{
				var r = p.Releases.Find(i =>	i.Channel == query.Channel &&
												i.Platform == query.Platform);

				if(r != null)
				{
					return new ReleaseAddress(query.Author, query.Product, query.Platform, r.Version);
				}
			}

			return null;
		}
	}
}
