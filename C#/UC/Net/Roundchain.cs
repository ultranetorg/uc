using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Net;
using System.Numerics;
using System.Security.Cryptography;
using System.Text;
using System.Threading.Tasks;
using Ipfs.Http;
using Nethereum.ABI.Util;
using Nethereum.BlockchainProcessing.BlockStorage.Entities;
using Nethereum.Hex.HexConvertors.Extensions;
using Nethereum.Model;
using Nethereum.Signer;
using Nethereum.Util;
using Nethereum.Web3;
using Nethereum.Web3.Accounts;
using Org.BouncyCastle.Utilities;
using Org.BouncyCastle.Utilities.Encoders;
using RocksDbSharp;

namespace UC.Net
{
	public delegate void BlockDelegate(Block b);

	public class Roundchain
	{
		class Genesis
		{
			public string Zone;
			public Cryptography Crypto;
			public string Rounds;
		}

		public const int									Pitch = 8;
		public const int									LastGenesisRound = Pitch*2;
		public const int									MembersMin = 7;
		public const int									MembersMax = 1024;
		public const int									NewMembersPerRoundMax = 1;
		public const int									NewHubsPerRoundMax = 1;
		public const int									HubsMax = 32;
		public const int									MembersRotation = 32;
		const int											LoadedRoundsMax = 100_000;
		public static readonly Coin							BailMin = 1000;
		//public static readonly Coin							FundablesPercent = 10;
		public static readonly Coin							FeePerByte = new Coin(0.000001);

		public static Account								OrgAccount = Account.Parse("0x00fe929a68368c301a1906ed39016ee9be3d937b");
		public static Account								GenAccount = Account.Parse("0x00ffea61659c02c4a38d5736767bec23ab8d2875");

		public Settings										Settings;

		public List<Round>									Rounds	= new();
		public Dictionary<int, Round>						LoadedRounds = new();
		public List<Peer>									Members	= new();
		public List<Account>								Funds = new();
		public List<Peer>									Hubs = new();

		public AccountTable									Accounts;
		public AuthorTable									Authors;
		public ProductTable									Products;
		public RocksDb										Database;
		
		public Log											Log;
		public BlockDelegate								BlockAdded;

 		public static readonly Account[]					Fathers =	{
																			Account.Parse("0x000038a7a3cb80ec769c632b7b3e43525547ecd1"),
																			Account.Parse("0x00015326bcf44c84a605afbdd5343de4aaf11387"),
																			Account.Parse("0x0002a311f7cf0aabfd3a248a89824bbd94a458a2"),
																			Account.Parse("0x00031174fcd4f971249e4112f925209a16813137"),
																			Account.Parse("0x0004761973068828923e7c811dd7f5b8eee0bae5"),
																			Account.Parse("0x0005a748d15de450cd488fbed9cc3b3213f042e5"),
																			Account.Parse("0x0006680ad7845cfb115cd56f834385817e93999a"),
																			//Account.Parse("0x0007f34bc43d41cf3ec2e6f684c7b9b131b04b41"),
																			//Account.Parse("0x00086c57b20ac627f1b04b7bf50bb27330438b6b"),
																			//Account.Parse("0x0009cc6575ddd868bc1476f7ea516af58125b0dd"),
																			//Account.Parse("0x000a52cad719404896a55f2dc2ea28dc7a6a9249"),
																			//Account.Parse("0x000b2dc121bd9114e7aab47754130f6148b38755"),
																			//Account.Parse("0x000c68d29c01f7e5873a9e353ee9af4d9505be93"),
																			//Account.Parse("0x000d381af6561f165a44680afa06e2360fd1e060"),
																			//Account.Parse("0x000ea12d3b17f96ef79ef4012db9df43a3d6da1b"),
																			//Account.Parse("0x000ff3c7e0b5c19447d5175cb4c6641cfa613152"),
 																		};

		readonly static List<Genesis>						Genesises =	new()
															{
																new Genesis {Zone = Zone.Localnet, Crypto = new NoCryptography(),		 Rounds = "000001020100000038a7a3cb80ec769c632b7b3e43525547ecd1000038a7a3cb80ec769c632b7b3e43525547ecd1000000000000000000000000620088857e2bd8107d10973587f7fc06938abaeec0531279c18a306f46b4bfaf00c0a80164030000ffea61659c02c4a38d5736767bec23ab8d287500ffea61659c02c4a38d5736767bec23ab8d28750000000000000000000000009462edf581a5e76ed7042f8a14a8d88536cf1b660bd24d963a73c6e1b438c9ae00000000000000000000000000000007c0a80164c0a80165c0a80166c0a80167c0a80168c0a80169c0a8016a000100fe929a68368c301a1906ed39016ee9be3d937b00080006680ad7845cfb115cd56f834385817e93999a000000000000000000000000cc68da1ec4802a53161ee4505a0dd354d3370d87dc25ec7976df35a077efb37f0000020101090000a0dec5adc93536c0a8016a020009000040bd8b5b936b6c000005a748d15de450cd488fbed9cc3b3213f042e50000000000000000000000003db9baf6c23ce50886c89ad4a15454fe35f0b4a126e5cafb3c6d46278c585f720000020101090000a0dec5adc93536c0a80169020009000040bd8b5b936b6c000004761973068828923e7c811dd7f5b8eee0bae500000000000000000000000025c7ef6c5fbba25040b6456ed8fccc84e8e63802eefcdc91994ee36223e6a5940000020101090000a0dec5adc93536c0a80168020009000040bd8b5b936b6c0000031174fcd4f971249e4112f925209a16813137000000000000000000000000ce774e8cb5870c2812ed3f7297df7a2b62beff77c0f3131d7c7546c1e837730c0000020101090000a0dec5adc93536c0a80167020009000040bd8b5b936b6c000002a311f7cf0aabfd3a248a89824bbd94a458a2000000000000000000000000c4f57261b1d1dfe64afd6405c2b7580d81df26d32808f074a3d3e0c8537a2c480000020101090000a0dec5adc93536c0a80166020009000040bd8b5b936b6c0000015326bcf44c84a605afbdd5343de4aaf1138700000000000000000000000095e69c2bdec171d0667f2ae391e5355c077672f9514e5b5aeda868cf64cb04550000020101090000a0dec5adc93536c0a80165020009000040bd8b5b936b6c00000038a7a3cb80ec769c632b7b3e43525547ecd1000000000000000000000000c2272b737a269f04420b9215316413927e6f2aec968eb45b3ac374362a36f0620000020101090000a0dec5adc93536c0a80164020009000040bd8b5b936b6c0000fe929a68368c301a1906ed39016ee9be3d937b00000000000000000000000034194c3da9e99cf9effd5c4e692165f6762ab4f1926e7ab0390d4bc2b2682b09000002040102756f0100020008000064a7b3b6e00d0001000101030100ffea61659c02c4a38d5736767bec23ab8d287500ffea61659c02c4a38d5736767bec23ab8d2875000000000000000000000000e3b5797a3e1223f35e67c92a580ab2418cddc397d88a7065ffec09b1d17442f6000081d8c4bd75000000000000000000000000000000000100fe929a68368c301a1906ed39016ee9be3d937b00000000000000000000000095d426f93628e237ec35d9d796236f4a7e037112c8379d955028e0a9bbc3115c000101050202756f02554fff02000101030200ffea61659c02c4a38d5736767bec23ab8d287500ffea61659c02c4a38d5736767bec23ab8d2875000000000000000000000000292da6cb781cc3e21587911b73d321da8281184280518ff30e4f118493de17bf000001000000000000000000000000000000000003000101030300ffea61659c02c4a38d5736767bec23ab8d287500ffea61659c02c4a38d5736767bec23ab8d287500000000000000000000000093f6e031029a73d9c0da96f5bfca7a9b06b370f3ec108b67ba031d4631bf531c000001000000000000000000000000000000000004000101030400ffea61659c02c4a38d5736767bec23ab8d287500ffea61659c02c4a38d5736767bec23ab8d28750000000000000000000000008458c6b3e1afe8b23d18de0893e94ae02c69c2fc0dc61aa29eb631b1118fe329000001000000000000000000000000000000000005000101030500ffea61659c02c4a38d5736767bec23ab8d287500ffea61659c02c4a38d5736767bec23ab8d28750000000000000000000000004a63d44b52eceb30e56c491e7366effe55339810ef110c83d6277d0b3a985ea0000001000000000000000000000000000000000006000101030600ffea61659c02c4a38d5736767bec23ab8d287500ffea61659c02c4a38d5736767bec23ab8d2875000000000000000000000000f72e41dd014a1c37dfc71bdf83803925ade36ba21add7c003b53c36e2301f469000001000000000000000000000000000000000007000101030700ffea61659c02c4a38d5736767bec23ab8d287500ffea61659c02c4a38d5736767bec23ab8d2875000000000000000000000000f1fcbb37f7af4b8d4cd4e65917a611ba15c7d561b4b262fba988bc2385f0736b000001000000000000000000000000000000000008000101030800ffea61659c02c4a38d5736767bec23ab8d287500ffea61659c02c4a38d5736767bec23ab8d2875000000000000000000000000910f0780d606a1145ebd990ac19b05bf2fd6185352d896b4b4aed4fed850fa890000010000000000000000000001000038a7a3cb80ec769c632b7b3e43525547ecd100000000000009000101030900ffea61659c02c4a38d5736767bec23ab8d287500ffea61659c02c4a38d5736767bec23ab8d287500000000000000000000000084ed3145f7c071af8a98b61ac640836ffd1fca22c2baf31e1af0877e7b837f4400000100000000000000000000000000000000000a000101030a00ffea61659c02c4a38d5736767bec23ab8d287500ffea61659c02c4a38d5736767bec23ab8d2875000000000000000000000000041ab6615f24eb1361ebe73949bc0fe9eef040e7126ba8130b442bb514b6b92900000100000000000000000000000000000000000b000101030b00ffea61659c02c4a38d5736767bec23ab8d287500ffea61659c02c4a38d5736767bec23ab8d287500000000000000000000000042480f9c319ad764865532755784329e8eeb63d720782d9c3b05d6cd688d84c700000100000000000000000000000000000000000c000101030c00ffea61659c02c4a38d5736767bec23ab8d287500ffea61659c02c4a38d5736767bec23ab8d2875000000000000000000000000789a0a80a51d6b8e71fc6a37f204319f3c80f675301aa084ed7f0570e25345ac00000100000000000000000000000000000000000d000101030d00ffea61659c02c4a38d5736767bec23ab8d287500ffea61659c02c4a38d5736767bec23ab8d2875000000000000000000000000a30c41abf124c9ee140d2b22b5b477e23bda1dff209525eea13efec1009f3b1700000100000000000000000000000000000000000e000101030e00ffea61659c02c4a38d5736767bec23ab8d287500ffea61659c02c4a38d5736767bec23ab8d287500000000000000000000000026f1e4285c1bbdd396ecb9bcfb5b48f6bacc81d6ef0e761d0907a71020942c2400000100000000000000000000000000000000000f000101030f00ffea61659c02c4a38d5736767bec23ab8d287500ffea61659c02c4a38d5736767bec23ab8d287500000000000000000000000042233ff58c14eb67b09b04543e8504d92dd68ed5a826c10cd936c2b793349cd2000001000000000000000000000000000000000010000101031000ffea61659c02c4a38d5736767bec23ab8d287500ffea61659c02c4a38d5736767bec23ab8d2875000000000000000000000000b0513606c22689ec2690f13d11c336ed32e033537952fe93d65f29b3a014b0db00000101910f07800001000038a70000000000010000000000000000"},
																//new Genesis {Zone = Zone.Local, Crypto = new EthereumCryptography(), Rounds = "0001000002030000ffea61659c02c4a38d5736767bec23ab8d28752118dcc5aa9c4ea5ac7a6baeb2c00fe795131249fff38aa123804415e92fc46067430454532a3445367b2f6fa24e6f0f1f71eeebf77d3f5179dbeec93eda59ea1b00000000000000000000000000000832b3d6ba18c945bbfc9baf44b52f65a449880b348520ccb42cd5fb38fc5016fe73c908ba73699e77c8c0d350ff14bc3d5f46e6d109f29cd21e4312679095a5f81b00000201090000a0dec5adc93536c0a8016a02080000c84e676dc11b000f31436863408437bf50c02865cab034aafe625d71fe4c9af7ccbbb72f7bd5b37feb8aba785eac0d60327ee7ab779525c12ee1957468336bc916c34a35273def1c00000201090000a0dec5adc93536c0a8016902080000c84e676dc11b00ae7ba257f8ae7dc6ae1c6c9a18f0947def9550a079abc02380020bea56162c37673c77412077a28c7e8e8d3803fbbdc11ff354dcf5f582d7aae42c5142a2b62e1c00000201090000a0dec5adc93536c0a8016802080000c84e676dc11b001a06703e7774c581c5f22c57e5d4ae01c7d3eb81e305ec5d32ae7521e6d53f836d9694151789a36e33dac68339f47bfe70b16c6b78fa6e8ca3ebcd44607b8ca11c00000201090000a0dec5adc93536c0a8016702080000c84e676dc11b00c97c2585746d1aed2eed862a21abeac3df1a4ceb2871429e3f40548660742159686039fdc966acc4679a8334b366c90db87333d849c5d92ed313625083f9981e1b00000201090000a0dec5adc93536c0a8016602080000c84e676dc11b006ffec6696eaf311a4e6d0b4ed03a3b8e4c7a37f8c4bd6f8e1a6568d3a58360916066f20a448846f1f5ce2fe0d494895dfc490278e38f70e94876e540f57231171b00000201090000a0dec5adc93536c0a8016502080000c84e676dc11b00e15bbcb49faa9daa8586b24aee9a1a7058b270e5325698eefb8507c7441616cf16fb8372bf549782c930b4e926affa5f30e01855a673a0142a95b730689996bb1c00000201090000a0dec5adc93536c0a8016402080000c84e676dc11b0089531e12cf910e62c26d5b8d5388527fa3d90b841955d385cfa9985482c706d054cef1778afbefa0ce61aeae488adb549b49dc29461e4348a32f6cf62d9a781a1b0000020402756f01000208000064a7b3b6e00d000100000038a7a3cb80ec769c632b7b3e43525547ecd1262509a8167f6693d39f21763f27134736a2b7ac3748f63f8bc602f7d6411ec357f4482ec576c8fca0c1e81f572ca0049461ed1c01a7cd5a1fb2fb64cdf3acf51cc0a8016400000000000101000001030100ffea61659c02c4a38d5736767bec23ab8d287515bb970258e792336b5b5a25a2776bb5545d86727877b66484e2cd938336721a6a79c88085bcefcab120b0983db1b64b6c0d3836a7a075f7672d8f96b03458b81b0081d8c4bd75000000000000000000000000011add463d846716812fb3d8992eef576e4e8aea1061a47ff5e4412fdadc32befc04e5db6b6074a017ee57b1cfce40f80f74aa7ae1b35a43212cc086bf914750c71b0101010502756f02554fff00000000000201000001030200ffea61659c02c4a38d5736767bec23ab8d2875726fa00c278d0194b0ed9b201949f2b2b579598afeeaf69a841b44149c5f9e1448ae784e390eb45adc8049beff11929d5eabfd388a29ee6713b7974541c8191a1c00010000000000000000000000000000000000000301000001030300ffea61659c02c4a38d5736767bec23ab8d28753eef6e8f4c15ddcfd8a6d7f18ed8d9f99a873523595a92a1fb4a2bc2e771bab84ddc51fcd004f55fa8a49597102d54195c18a4be6423b962bf58fa6fbe19dac61b00010000000000000000000000000000000000000401000001030400ffea61659c02c4a38d5736767bec23ab8d2875e4d286f6fd65b81e96a3612c32edcb047ee164c163fdb2443a6dbd95fde57493559f726e39eb0944f8e670005e1effe59e124e19fe9d4da5d6dc6f749c2eb7781b00010000000000000000000000000000000000000501000001030500ffea61659c02c4a38d5736767bec23ab8d28752b8041c52bc22ae8fab2e95c2a03223e84bad203db2f1bd34957e41d18a774f06a6a3e1ec12aacf994a3c8bc61d587d0984b4d223369cd38be0425f9ba9ede291b00010000000000000000000000000000000000000601000001030600ffea61659c02c4a38d5736767bec23ab8d2875511857c0b4df66d58af0c1237f1e55e3508d4232c1c9c7935b8576861ab9869c330d429aaab5587e9c19d61d4c68f0c7e5cd3223ab62ed3c09ff0f85a2d7c2be1b00010000000000000000000000000000000000000701000001030700ffea61659c02c4a38d5736767bec23ab8d2875b890b2162ca8b00993baf33d84568b67343212bf7fca18eb04e1677dd55fe7bd32e2dd35822c66d2612222a3100713eee5772719ccc244ad98480fee2292de391c00010000000000000000000000000000000000000801000001030800ffea61659c02c4a38d5736767bec23ab8d2875ee02ea3c839beb5929dc5bd7015d9a508419dffcff6d82d64fc35bb0d7c29ca66c7eaa76f023d11a5e277241b217f51458b4bbb26b695de51443b646f239131c1c0001000000000000000001000038a7a3cb80ec769c632b7b3e43525547ecd10000000000000000000901000001030900ffea61659c02c4a38d5736767bec23ab8d28752d86e829f4f3467a2a7d35411992baed3f646b25bb94da7b858320e8d92e0f153b410caa15ff00f0daef27915834118842c4ee23e918f14bd384be2b14e388841c0001000000000000000000000100fe929a68368c301a1906ed39016ee9be3d937b000000000000000a01000001030a00ffea61659c02c4a38d5736767bec23ab8d2875a1ab94398ff9ed9488233381df7aec80cd239e9f60cf5d3473a07f0c87774c7932ef58a0246dde93a989f4581c8a6a98fbb550eddafdad9b76270dbf7ae86a4e1c00010000000000000000000000000000000000000b01000001030b00ffea61659c02c4a38d5736767bec23ab8d287582bd2bf95a787747a6ded0e177430b660b59e1cd8f15eedd7473197e2bfeae2f01fe94ebd4a25c5c07b203993b873df3635eea3f558c4b04b45c824f0c7f9e551b00010000000000000000000000000000000000000c01000001030c00ffea61659c02c4a38d5736767bec23ab8d28758bdd4fe8f8a51e305c1047c3cbb60f71e49e225b62a2a9d0ad24288f24d599193c624422c21ad0a689d07222eaa574ca3ab5d74d1f4ee0e7bee7ec9713964caf1b00010000000000000000000000000000000000000d01000001030d00ffea61659c02c4a38d5736767bec23ab8d28751f7cad65a8132dd003cc78f5cd2072b968eab3fbc81723412744f687570b3d381c2a4a04902125201583da4914d9a0a3f0e8ff7a8abbd458626209269a05b2091c00010000000000000000000000000000000000000e01000001030e00ffea61659c02c4a38d5736767bec23ab8d2875756b64452b2da3d326f9f457eba3ff70c2fa91dc726b0adecb867a340ae2be256b4059e38f16a4f1bc28fb7bbf341b83de39d52bf53fff3da53a52d7981a735c1c00010000000000000000000000000000000000000f01000001030f00ffea61659c02c4a38d5736767bec23ab8d287508994bf6f6ade6ea4327286abc5e5a91d7ea8877817d1f10125ea5e5d5f347f955b7c714ff44119171552674a1b3323263f201bad656719708fd30ed3ece58fc1b00010000000000000000000000000000000000001001000001031000ffea61659c02c4a38d5736767bec23ab8d28753311bef7c11f68a9fd87a6f624f77dbcaea32116972ae7662dc30f9b562d5da77d9defa7040c6b2bac8644902e795c9e7b83e2f0e64662d89c1b6c54d62d20b71b000101763880ea0001000038a7000000010000000000000000000000"},

																new Genesis {Zone = Zone.Testnet0,	Crypto = new EthereumCryptography(), Rounds = "0001000002030000ffea61659c02c4a38d5736767bec23ab8d287533cb3ac7add11304966337c25d2c343b765e6972d481b7955b91de0822902c574345e9722b7165451470b4c2ecbf51bc3876c97a363a15209036d7153f0fa88f1b0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008841c4fbd07e9852d651286a1aad4d8bfc6ee475e02c58c8a8424308e35f176810ce46cb2e8bce6b88ec3a86484f6fd915d1ab1a9f288d369e07aa53528bcca861c00000201090000a0dec5adc935364e2fcde50209000040bd8b5b936b6c00e4b3625c1b8b4f512e8fcf3a37ab09eedf66472f7b8883cec55ef950b89ee3d92950e02222ecc6c54fc9c1b360d0cb43b1912e46427f3775917f91af16567d6f1b00000201090000a0dec5adc935364e2fc6da0209000040bd8b5b936b6c00ff54c76828026d02721dca6235422d70d20920f54bf4af72cb0067f4bc47d82705b1b27c064228710f0632b80b43ee58b3739c9d3366971f7e6e8fb09dc5d4b71c00000201090000a0dec5adc935364e2fd6ab0209000040bd8b5b936b6c007bf2930038cfe8a55c64d2e8efaea9600686e14e19d7124b1dcc46824b9501fd10337a1865893b1e9b94ae6fe16a8b62283d9f449322fd4958fe3139ef0dae8b1b00000201090000a0dec5adc935364e2fd6aa0209000040bd8b5b936b6c0093fc5d0e116b8800a96a920843dc25ac7da62aa589a94f78dca8dea745a972d3713bc66e82cce5aa68e680549eb93f3caae23f65a52a25215da7f1bca9cb5bed1c00000201090000a0dec5adc935364e2fd6a60209000040bd8b5b936b6c0081b8a20bccf847858db4d0d9debc96c06c672f2d8e33f425e3602d5c8b3a10e37f72729b4f41df7e62779ac00e6c6133b35fe21c0c6f44dfe565b92ed6bece381c00000201090000a0dec5adc935364e2fd6a10209000040bd8b5b936b6c0078725dede4f416ce7fea07335e8c585f51fc3205bb362990238ae7a3db4ffd9b3aea09dfcdc9075a4964f966eac82c660288ce2db428ba9653f66dde1dde6a171c00000201090000a0dec5adc935364e2fcc640209000040bd8b5b936b6c006c21fdae2a60eb686d65586551efb91809524ca27ccf4174d86809c5f646ef704af5af3ccad81d17691a4665906cc80d69627f1cf6b34bbb1ca7f1442e022d6f1c0000020402756f01000208000064a7b3b6e00d000100000038a7a3cb80ec769c632b7b3e43525547ecd1ed9aff0d4b41645d58886edacf4259fba842441ecffec9f080520b1beb31ecdf4df826dcb79c39b06c38df08546bd1b7fbcdf4a01a355d8474a8ddcc9af036b61c4e2fcc6400000000000101000001030100ffea61659c02c4a38d5736767bec23ab8d2875dea52621c09ec7ae411fb757a08cf3c8b0f666f4311114926453b27cfdf4adcc7d2a139fae7a0bc6ea5aa4d8b1154aa9cd08069f5234fb2797c0b3bc60a8369e1c0081d8c4bd75000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001344a20f323561bb2e6262a65e8a62360a1de13e1d3ce799516ac6268b247a56e2137826c1f634f11d14cc2f462c249460f63fc88662e921602f4d73311acd5991b0101010502756f02554fff00000000000201000001030200ffea61659c02c4a38d5736767bec23ab8d28752f7d1dd5253f25ca054505974ae86ae01f6e572caa329c39c22d8162e3aea3344f8ec3bce8ade9014a4a1e214a8ef798a5ff99426049edaa5b4ef6bdaa673ab31b000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000301000001030300ffea61659c02c4a38d5736767bec23ab8d287588c8bd67ba998789eadeeb45dc71d7bbec59699f513f566f01b465e06950f13655043faa8a4333ab837a20bb02d618eced00b12b84f7e2339aa5bf91a47b519a1c000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000401000001030400ffea61659c02c4a38d5736767bec23ab8d28751d595cdd2dc2a293e93e52393f6a2a767269e48f8b0114798e7fe6c8ee4d8a5d28a73bef43f5cda4a8b2849a205cfb1fe6031efd966bec7c4072ca5c485d47931b000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000501000001030500ffea61659c02c4a38d5736767bec23ab8d2875ed68b322797dbd2808eef00c119b46101ca380227094c8903bef1fe0881526be7b6d6c2574eaa18acee3a83f55003f6e578a3de86aa522d0ad4e681c9ac3b5c91c000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000601000001030600ffea61659c02c4a38d5736767bec23ab8d2875ff2ce26d6a5c1dc6e0b300f0e25e02c460644815614c84490dfa95ec64ed698315b09010e603ea8ad1d54be1c614b166dc9cbb5c9d18e4cbc9182a7c9fbf4bc11b000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000701000001030700ffea61659c02c4a38d5736767bec23ab8d2875d41c87cc005bbaa787873be938b8cb382e23fa74005af1e07cf5daa266e26ca302b4d45b6dfaafa343e6f4ade2c4793a91ccd830218eeed37add01b692a5cd491c000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000801000001030800ffea61659c02c4a38d5736767bec23ab8d28754181fb4d1798e4f7db57831814500476e2254206a49aac05a0ca157e2c8368796bfadc783fc0d72cb185c40b31d4923bf3eb5a71944ee4e55349c8775724e9f71c00010000000000000000000000000000000000000000000000000000000000000000000000000000000001000038a7a3cb80ec769c632b7b3e43525547ecd10000000000000000000901000001030900ffea61659c02c4a38d5736767bec23ab8d287539cbc43587904a6ab28b9920dc5a9fc3d7a41155a810dc87292b9ae13c07eb88153c58d9edee0efe3fc9a0f9c7b7384a44280952cd14170042c9d6ead596b5a41c00010000000000000000000000000000000000000000000000000000000000000000000000000000000000000100fe929a68368c301a1906ed39016ee9be3d937b000000000000000a01000001030a00ffea61659c02c4a38d5736767bec23ab8d2875dc6f77a9e890a534cf317806fe493c571c9c98e94716f548b6216dc3df92eb5b2ee01409b6f165ea28b3145b4a95dcf250c783a97eb5fea2a1d5027b7b9685141c000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000b01000001030b00ffea61659c02c4a38d5736767bec23ab8d2875162e6b4ae50f27015d47f2cc71be16c867ed870ed23510a04e9f1b18d7b6a0f64a42c4a84584ca3a96bd2373c8fea576138f7ea3d4e2dd25ff48988792fd38ae1b000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c01000001030c00ffea61659c02c4a38d5736767bec23ab8d2875affc0c8b2975d8ff55f2822dafc52bf02dc66bea66bcd70eada83ec2abfe87eb6ebcdcaab67e80ca029ea622ba1dc805a7e814ed2bc266b18822a3ce59e420971c000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000d01000001030d00ffea61659c02c4a38d5736767bec23ab8d287558338bcf99d66248eaff7a40b82853b00b718a90f8ea075d64fae8f5bde976380dbef353a561ca8949d3eecffafca24b84a1ac3bb692e8c3cadf7d648db9cebb1c000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e01000001030e00ffea61659c02c4a38d5736767bec23ab8d2875ca2c6ae9b62bf37b2e18858cb394f9011564048bae1e4b83c9fc7eecb7635bc71e859155a30805bfc671d55f3364199e29253b878b59184050b781fcb05e16491b000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f01000001030f00ffea61659c02c4a38d5736767bec23ab8d287587c391ef9852490c8ee6da369527e3add67b95f18ea655a1b8febfb9a96172ed5fceee685c665ad6f564680e797a0d8686cc43822eb9f6d4be11f071ad5313851b000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001001000001031000ffea61659c02c4a38d5736767bec23ab8d2875446bf064a5dd466f835e52e230e6d416248d0857e8e7b91021715ace63f63f740ff07cf662f322e53e83020b1dd25a15cd501d9728ad5420eaae4ef1794bcbd81b000122df927e5298d841286e8f9661134ee764a13ae915d5a2735ef6b153592c08fd01aa6b96100001000038a7000000010000000000000000000000"},
																new Genesis {Zone = Zone.Testnet1,	Crypto = new EthereumCryptography(), Rounds = "0001000002030000ffea61659c02c4a38d5736767bec23ab8d28755fa1adabd7c2ec77529938a26038d40d0351959c087dc422d0b047c2081cf0e57c843831f6ee6b353c9aee47bb83f060f96722a9e15092739ba0eed55403d6411b000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000895acda618b9f0183c376fd31e6ca78e18717a881d960020e1b6c35f0b9df49ae0c604f20f6e39f4d055ed61baf9b021b178e213d44c1b1c918dc9ed7e417cf491c00000201090000a0dec5adc935364e2fcde50209000040bd8b5b936b6c005cf38e77111b17699b214c34d43dab5f9cea793d617cac8f0696206872ca64fb24faf717d3ce5dd3be6f2667a01f7a3debb1ead79eb19cf0e1b3ef14528e41631c00000201090000a0dec5adc935364e2fc6da0209000040bd8b5b936b6c00f0b6346c05052c2a1ea2a028e315da49ed06eff555b6b288db94c8cfde7eeb2720d6dbc9f335e456a684f2d2c57d96a206b065499d9c88257f5878e51f148a9b1c00000201090000a0dec5adc935364e2fd6ab0209000040bd8b5b936b6c002d05d09d6bdd1a0f67d8f3eb87ef0f3c9112eb1acb2980226729a2c99ec7d5f966516d3287f6b8061b1645bab1a41739b7fa9bf97f1cfd985bc901954c44b1041c00000201090000a0dec5adc935364e2fd6aa0209000040bd8b5b936b6c00edd1e6ae78e533744dd257b13a56c4384b8b03c7b26613bd7546759705719919248a99d3f153019cc2996d3869b46843124b307d992dd3285a8c5c40606b49e21b00000201090000a0dec5adc935364e2fd6a60209000040bd8b5b936b6c00ba07541515b84b58dc4cd95378019b511255c6f3ec41745c2128c52f9819ce0121395c080114a0ac8bd34bbd93c5ee9b8ffb29b862de13a18b987da37d87d3b31b00000201090000a0dec5adc935364e2fd6a10209000040bd8b5b936b6c000b1ab68bfa4ddf4754bd0bfc741a0aff13079aa62af528d450f1c23d455db5ff6f00ac1e1c951ab3a7b3e4e4b7f0f60ef565f2742f9c779c19483e4b4736f53c1b00000201090000a0dec5adc935364e2fcc640209000040bd8b5b936b6c0012f3e95186164878c1376a5caea0ba6a8a39ebd51f10bc9b25b0257e42ee460227242e791d55a0c5af3506bde7702c1f904ae1692204e3846935c33c3a6ac9b11c0000020402756f01000208000064a7b3b6e00d000100000038a7a3cb80ec769c632b7b3e43525547ecd1f5134209d039b6b90e792450dbe8d0aa771a450b479c161b13cc0d056b46558d78b427946ed87451efca7890c0e4a2787ae4bb7f5b5c1f15372718a180f922d41b4e2fcc6400000000000101000001030100ffea61659c02c4a38d5736767bec23ab8d28751d186d9c0f0d7171da0bc05fab424e35f4ff38f6c029fbb33f78daef83cf7d042b836f0a728f5536a2187394a721233a5c821c679bf3839d83cdbe9b20bcace21c0081d8c4bd75000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001f6b485a103d7d96a0c1a44ae6ce21779016c9bfb83de3fe1650c785a11b30c8315faf797da9cacadcc64dbc35a6986eb0246e258e6297254e07ac81d58ec89bb1b0101010502756f02554fff00000000000201000001030200ffea61659c02c4a38d5736767bec23ab8d2875a190c948a57868b77f322417c4f322fae5b0fbb5b1c622bd58381777258bbf021f77756102cd99828652651d4f3813b6ff85478083e1aa0a11d0495aa8eb61d71b000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000301000001030300ffea61659c02c4a38d5736767bec23ab8d2875fa4bd93346fb824c5e2bd14b7d2d538b76cf6395b0bfc4322c94df3e21b0c0652cecf1510b9257727b4cf67906c2152d6fe0978a9204b7fe4e66449c4feb573d1c000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000401000001030400ffea61659c02c4a38d5736767bec23ab8d2875e59fc17e2f56bdd8dddf9bcb906956f3f975408a7695947ea8e308974dc0c30f5666095714be85ab42277f741599500d54424ae02b30c1bb19975d28a1253f501b000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000501000001030500ffea61659c02c4a38d5736767bec23ab8d287568a231b362621b92de28f05c669471aa1f2fc7c5ca745487a6645f2ebb1e648632d655cd190787c2c2c08d18f3923e7a0432ce0d149092ab364f8469a73e73541c000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000601000001030600ffea61659c02c4a38d5736767bec23ab8d28757907791a0d187ffd3ae8958e7e9eb1cb0c1554a7eb014d79225565b04ebec2fa4fd183bfa78d0db28c3b0f94bc58c9c3570215cae3d63f3359493fd81f9a16fa1b000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000701000001030700ffea61659c02c4a38d5736767bec23ab8d2875537b9f73e964abac44eb5d955704cf04c61527d58168aad2c4ad1c75a499f8ef396338d488d23a40edc3ee92c0fbdc3e1ddc03812c6aac24a7a5dd645f646d431c000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000801000001030800ffea61659c02c4a38d5736767bec23ab8d2875599d41e8a42694135989e301e5debd7eb302a93f59ddddb23b75059da382dae50eb6e9af458bf0d71623750574b9981a81bab6531d0b2e955ed89809da08e4ed1b00010000000000000000000000000000000000000000000000000000000000000000000000000000000001000038a7a3cb80ec769c632b7b3e43525547ecd10000000000000000000901000001030900ffea61659c02c4a38d5736767bec23ab8d287573bbe354343b94867c78d742dc63b088812303281c2a7848e0a063b04a0436d975ccd1b4da17ce577c465c415facc0443c15b3ae67b90259b4417fbff53c07531b00010000000000000000000000000000000000000000000000000000000000000000000000000000000000000100fe929a68368c301a1906ed39016ee9be3d937b000000000000000a01000001030a00ffea61659c02c4a38d5736767bec23ab8d287566472f7c337c8a2badfd47ad838a3802d895c1d8aac8a5e30dc78083d8c5912d5a7c8ee1029b26c7f690f25220766295ae58fe29d604201170b2144f38811a721c000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000b01000001030b00ffea61659c02c4a38d5736767bec23ab8d287517a321a967e57c1d05dc635ae88ace4c63d4de96626afb50b6230dcdae6154955c2a186886086d1a88e00a432d080020a0f5e513cfb1c1584f2c58646308e66e1b000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c01000001030c00ffea61659c02c4a38d5736767bec23ab8d2875fcf4e4a7a5dac9a31a2c9c5938d924c7085fa09772b9567051efb2f3b210692c263417202bb6adf0f1ec6869735c53073984ce47264cc66c94337998a2678a931c000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000d01000001030d00ffea61659c02c4a38d5736767bec23ab8d287511d154f93c59283954adf971c244cb6dbd68e7a4c3d5c1fc24e62170e2edca2638d0a75dabfeeed6d9851a52ea59fac62be0f0b3abb48cf6b33184847cda5fd91b000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e01000001030e00ffea61659c02c4a38d5736767bec23ab8d2875bcf3c2b44d60f27a212f97e41b70e874e54630e5c12114caa2e94070fec0467a272abffdd704c4345bee4d485e881fb732baa9d0ef8ab9e99378d41a2531eb291c000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f01000001030f00ffea61659c02c4a38d5736767bec23ab8d2875546239868668e789176f6bf5a34ec90e41ef6e4eae359e963872b0ed9f2358c25e5c5576d00dc638395d28e6b9053cd4b37f685d922de0b30414248130f5ead11b000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001001000001031000ffea61659c02c4a38d5736767bec23ab8d28751ea77332e14a8e6d04d891eed600a17a239349d061d3e9a378cc05c449d1645c207781e059e0e3c91e93a406ce21617c2c618fdb546b55bbcdf44c6217a201801b000190c8b461fc5a4cdafc78cefadf1cec7750fdc8c617d66e26e31301a621fed7e20110f4f2780001000038a7000000010000000000000000000000"},
															};

		readonly byte[]										LastRoundKey	= new byte[] {1};
		readonly byte[]										WeiSpentKey		= new byte[] {2};
		readonly byte[]										FactorKey		= new byte[] {3};
		readonly byte[]										EmissionKey		= new byte[] {4};
		readonly byte[]										MembersKey		= new byte[] {5};
		readonly byte[]										FundablesKey	= new byte[] {6};

		public Round										LastConfirmedRound	=> Rounds.FirstOrDefault(i => i.Confirmed) ?? LastSavedRound;
		public Round										LastVotedRound		=> Rounds.FirstOrDefault(i => i.Voted) ?? LastConfirmedRound;
		public Round										LastNonEmptyRound	=> Rounds.FirstOrDefault(i => i.Blocks.Any()) ?? LastConfirmedRound;
		public Round										LastPayloadRound	=> Rounds.FirstOrDefault(i => i.Blocks.Any(i => i is Payload)) ?? LastConfirmedRound;
		Round												LastSavedRound	{
																				get
																				{
																					var d = Database.Get(LastRoundKey);

																					if(d == null)
																						return null;
																					else
																						return FindRound(BitConverter.ToInt32(d));
																				}
																			}

		public BigInteger									LastSavedWeiSpent	=> new BigInteger(Database.Get(WeiSpentKey));
		public Coin											LastSavedFactor		=> new Coin(Database.Get(FactorKey));
		public Coin											LastSavedEmission	=> new Coin(Database.Get(EmissionKey));

		public ColumnFamilyHandle							AccountsFamily	=> Database.GetColumnFamily(nameof(Accounts));
		public ColumnFamilyHandle							AuthorsFamily	=> Database.GetColumnFamily(nameof(Authors));
		public ColumnFamilyHandle							ProductsFamily	=> Database.GetColumnFamily(nameof(Products));
		public ColumnFamilyHandle							RoundsFamily	=> Database.GetColumnFamily(nameof(Rounds));
		public ColumnFamilyHandle							MembersFamily	=> Database.GetColumnFamily(nameof(Members));
		public ColumnFamilyHandle							FundablesFamily	=> Database.GetColumnFamily(nameof(Funds));

		public static int									GetValidityPeriod(int rid) => rid + Pitch;

		public Roundchain(Settings settings, Log log, INas nas, Vault vault, RocksDb database)
		{
			Settings = settings;
			Log = log;
			Database = database;

			///GenerateFathers(256);

			Accounts = new AccountTable(this, AccountsFamily);
			Authors = new AuthorTable(this, AuthorsFamily);
			Products = new ProductTable(this, ProductsFamily);

			if(LastSavedRound == null)
			{
				var ips = nas.GetInitials(settings.Zone).ToArray();

				if(Settings.Dev.GenerateGenesis)
				{
					var s = new MemoryStream();
					var w = new BinaryWriter(s);

					var gen = vault.GetFather(GenAccount);
					var org = vault.GetFather(OrgAccount);

					//long datebase = 1900;

					void write(int rid)
					{
						var r = FindRound(rid);
						r.Voted = true;
						//r.Confirmed = true;
						r.Write(w);
					}

					var b0 = new Payload(this)
							{
								RoundId		= 0,
								TimeDelta	= 0,
								Reference	= RoundReference.Empty,
							};

					var jr = new GeneratorJoinRequest(this)
								{
									RoundId	= 0,
									IP		= ips[0]
								};
					jr.Sign(vault.GetFather(Fathers[0]));
					Add(jr, false);

					var t = new Transaction(Settings, org);
					t.AddOperation(new Emission(org, Web3.Convert.ToWei(1, UnitConversion.EthUnit.Ether), 0){ Id = 0 });
					t.AddOperation(new AuthorBid(org, "uo", 0){ Id = 1 });
					t.Sign(gen, 0);
					b0.AddNext(t);
						
					for(int i=0; i<Fathers.Length; i++)
					{
						var f = vault.GetFather(Fathers[i]);
					
						t = new Transaction(Settings, f);
						t.AddOperation(new Emission(f, Web3.Convert.ToWei(settings.Zone == Zone.Mainnet ? 2 : 2_000, UnitConversion.EthUnit.Ether), 0){ Id = 0 });
						t.AddOperation(new CandidacyDeclaration(f, new Coin(1000), ips[i]){ Id = 1 });
						t.Sign(gen, 0);

						b0.AddNext(t);

						b0.HubJoiners.Add(ips[i]);
					}

					b0.FundJoiners.Add(OrgAccount);

					b0.Sign(gen);
					Add(b0, false);

					write(0);
					
					for(int i = 1; i < Pitch; i++)
					{
						var b = new Payload(this)
								{
									RoundId		= i,
									TimeDelta	= i == 1 ? ((long)TimeSpan.FromDays(365).TotalMilliseconds + 1) : 1,  //new AdmsTime(AdmsTime.FromYears(datebase + i).Ticks + 1),
									Reference	= RoundReference.Empty,
								};

						if(i == 1)
						{
							t = new Transaction(Settings, org);
							t.AddOperation(new AuthorRegistration(org, "uo", "UO", 255){ Id = 2 });
							t.Sign(gen, i);
							b.AddNext(t);
						}
							
						b.Sign(gen);
						Add(b, false);

						write(i);
					}

					for(int i = Pitch; i <= LastGenesisRound; i++)
					{
						var p = GetRound(i - Pitch);

						var b = new Payload(this)
								{
									RoundId		= i,
									TimeDelta	= 1,  //new AdmsTime(AdmsTime.FromYears(datebase + i).Ticks + 1),
									Reference	= Refer(p)
								};
	
						if(i == Pitch)
							b.Joiners.Add(Fathers[0]);

						b.Sign(gen);
						Add(b, false);

						write(i);
					}
					
					var g = s.ToArray().ToHex();
					
					if(g != Genesises.Find(i => i.Zone == Settings.Zone && i.Crypto.GetType() == Cryptography.Current.GetType()).Rounds)
						throw new IntegrityException("Genesis update needed");

					Rounds.Clear();
				}

				var rd = new BinaryReader(new MemoryStream(Genesises.Find(i => i.Zone == Settings.Zone && i.Crypto.GetType() == Cryptography.Current.GetType()).Rounds.HexToByteArray()));
	
				for(int i = 0; i < Pitch*2 + 1; i++)
				{
					var r = new Round(this);
					r.Read(rd);
	
					Rounds.Insert(0, r);
			
					if(i == Pitch)
					{
						r.ConfirmedJoiners = new ();
						r.ConfirmedJoiners.Add(Fathers[0]);

						r.ConfirmedFundJoiners = new ();
						r.ConfirmedFundJoiners.Add(OrgAccount);

						r.ConfirmedHubJoiners = new ();

						for(int j=0; j<Fathers.Length; j++)
						{
							r.ConfirmedHubJoiners.Add(ips[j]);
						}
					}

					r.ConfirmedViolators	= r.ConfirmedViolators		?? new();
					r.ConfirmedJoiners		= r.ConfirmedJoiners		?? new();
					r.ConfirmedLeavers		= r.ConfirmedLeavers		?? new();
					r.ConfirmedHubJoiners	= r.ConfirmedHubJoiners		?? new();
					r.ConfirmedHubLeavers	= r.ConfirmedHubLeavers		?? new();
					r.ConfirmedFundJoiners	= r.ConfirmedFundJoiners	?? new();
					r.ConfirmedFundLeavers	= r.ConfirmedFundLeavers	?? new();

					foreach(var p in r.Payloads)
						p.Confirmed = true;

					if(r.Id > 0)
						r.Time = CalculateTime(r, r.Unique.OfType<Payload>());

					r.Confirmed = true;

					Seal(r);
				}

				if(!Rounds.All(i => i.Payloads.All(i => i.Transactions.All(i => i.Operations.All(i => i.Successful)))))
				{
					throw new IntegrityException("Genesis construction failed");
				}
			}
			else
			{
				var r = new BinaryReader(new MemoryStream(Database.Get(MembersKey)));
				Members = r.ReadList<Peer>(() => { var p = new Peer(); p.ReadMember(r); return p; }).ToList();

				r = new BinaryReader(new MemoryStream(Database.Get(FundablesKey)));
				Funds = r.ReadList<Account>();
			}
		}

		public string GenerateFathers(int n)
		{
 			var accs = new EthECKey[n];
 
 			var tasks = new Task[n];
 
 			for(int i=0; i<n; i++)
 			{
 				tasks[i] =	Task.Run(() =>
 							{
 								while(accs.Contains(null))
 								{
 									var k = EthECKey.GenerateKey();
 	
 									var pub = Sha3Keccack.Current.CalculateHash(k.GetPubKeyNoPrefix());
 					
 									if(pub[12] == 0x00)
 									{
 										var i = pub[13];
 		
 										if(i < n && accs[i] == null)
 										{
 											accs[i] = k;

											byte[] array2 = new byte[pub.Length - 12];
											Array.Copy(pub, 12, array2, 0, pub.Length - 12);

											new PrivateAccount(k).Save(Path.Join(Settings.Secret.Fathers, "0x" + array2.ToHex()), Settings.Secret.Password);
 										}
 									}
 								}
 							});
 			}
 
 			Task.WaitAll(tasks);
 
 			return string.Join(Environment.NewLine, accs.Select(i => i.GetPrivateKey()));
		}

		public void Add(Block b, bool execute = true)
		{
			var r = GetRound(b.RoundId);

			b.Round = r;
			r.Blocks.Add(b);

			if(execute)
			{
				if(b is GeneratorJoinRequest jr)
				{
					jr.Declaration = Accounts.FindLastOperation<CandidacyDeclaration>(jr.Generator);
				}
				else if(b is Payload)
				{
 					for(int i = r.Id; i <= LastPayloadRound.Id; i++)
 					{
 						var ir = GetRound(i);
 						
 						if(ir.Payloads.Any())
 							Execute(ir, ir.Payloads, null);
 						else
 							break;
 					}
				}

				if(b is Vote v && r.FirstArrivalTime == DateTime.MaxValue)
				{
					r.FirstArrivalTime = DateTime.UtcNow;
				} 
			}

			BlockAdded?.Invoke(b);
		}

		public void Add(IEnumerable<Block> bb)
		{
			foreach(var i in bb)
			{
				Add(i);
			}
		}

		public bool Verify(Block b)
		{
			if(b.RoundId <= LastConfirmedRound.Id)
				return false;

			var r = FindRound(b.RoundId);
	
			if(r != null && r.Blocks.Any(i => i.Signature.SequenceEqual(b.Signature)))
				return false;
		
			return b.Valid;
		}

		public Round GetRound(int rid)
		{
			var r = FindRound(rid);

			if(r == null)
			{	
				r = new Round(this) {Id = rid};
				r.LastAccessed = DateTime.UtcNow;
				Rounds.Add(r);
				Rounds = Rounds.OrderByDescending(i => i.Id).ToList();
			}

			return r;
		}

		public Round FindRound(int rid)
		{
			foreach(var i in Rounds)
				if(i.Id == rid)
				{
					i.LastAccessed = DateTime.UtcNow;
					return i;
				}

			if(LoadedRounds.ContainsKey(rid))
			{
				var r = LoadedRounds[rid];
				r.LastAccessed = DateTime.UtcNow;
				return r;
			}

			var d = Database.Get(BitConverter.GetBytes(rid), RoundsFamily);

			if(d != null)
			{
				var r = new Round(this);
				r.Id			= rid; 
				r.Voted			= true; 
				r.Confirmed		= true;
				r.LastAccessed	= DateTime.UtcNow;

				r.Load(new BinaryReader(new MemoryStream(d)));
	
				LoadedRounds[r.Id] = r;
				Recycle();
				return r;
			}
			else
				return null;
		}

		void Recycle()
		{
			if(LoadedRounds.Count > LoadedRoundsMax)
			{
				foreach(var i in LoadedRounds.OrderByDescending(i => i.Value.LastAccessed).Skip(LoadedRoundsMax))
				{
					LoadedRounds.Remove(i.Key);
				}
			}
		}

		public IEnumerable<Peer> VotersFor(Round r)
		{
			return Members.Where(i => i.JoinedGeneratorsAt < r.Id);
		}

		public IEnumerable<GeneratorJoinRequest> JoinersFor(Round round)
		{
			return FindRound(round.ParentId).JoinRequests.Select(jr =>	{
																			var d = Accounts.FindLastOperation<CandidacyDeclaration>(jr.Generator, rp: r => r.Confirmed && r.Id <= round.ParentId - Pitch);
																			return new{jr = jr, d = d};
																		})	/// round.ParentId - Pitch means to not join earlier than [Pitch] after declaration, and not redeclare after a join is requested
															.Where(i => i.d != null && i.d.Bail >= (Settings.Dev != null && Settings.Dev.DisableBailMin ? 0 : BailMin))
															.OrderByDescending(i => i.d.Bail)
															.Select(i => i.jr);
		}

		public IEnumerable<Account> ProposeJoiners(Round round)
		{
			var joiners = JoinersFor(round);

			var n = Members.Count < MembersMax ? MembersMax - Members.Count : MembersRotation;

			//.Where(i =>	{ 
			//				var d = Accounts.FindLastOperation<CandidacyDeclaration>(i, null, null, null, r => r.Id <= round.Id);
			//				return d != null && d.Transaction.Payload.RoundId <= round.Id - Pitch*2 && d.Bail >= (Settings.Dev != null && Settings.Dev.DisableBailMin ? 0 : BailMin); 
			//			})

			return joiners.Take(n).Select(i => i.Generator);
		}

		public IEnumerable<Account> ProposeLeavers(Round round, Account generator)
		{
			var joiners = JoinersFor(round);

			var o = VotersFor(round).Where(i =>	i.JoinedGeneratorsAt < round.ParentId &&
												Rounds.Count(r =>	round.ParentId <= r.Id && r.Id < round.Id &&					/// in previous Pitch number of rounds
																	r.Blocks.Any(b => b.Generator == i.Generator)) < Pitch * 2/3 &&	/// sent less than 2/3 of required blocks
												!Enumerable.Range(round.Id - Pitch + 1, Pitch - 1).Select(i => FindRound(i)).Any(r => r.Votes.Any(v => v.Generator == generator && v.Leavers.Contains(i.Generator))) /// not yet reported in prev [Pitch-1] rounds
											)	
												
									.Select(i => i.Generator);

			if(!o.Any() && Members.Count == MembersMax && joiners.Any())
				return Members.OrderByDescending(i => i.JoinedGeneratorsAt).Take(joiners.Take(MembersRotation).Count()).Select(i => i.Generator);
			else
				return o;
		}

		public IEnumerable<IPAddress> ProposeHubJoiners(Round round)
		{
			var joiners = FindRound(round.ParentId).Blocks.OfType<HubJoinRequest>().OrderBy(jr => jr.IP.GetAddressBytes(), new BytesComparer());

			var n = HubsMax - Hubs.Count;
			//var n = Hubs.Count < HubsMax ? HubsMax - Members.Count : HubsMaxRotation;

			return joiners.Take(n).Select(i => i.IP);
		}

		public IEnumerable<IPAddress> ProposeHubLeavers(Round round)
		{
			return new IPAddress[0];
		}

		public bool QuorumReached(Round r)
		{
			var members = VotersFor(r).Select(i => i.Generator);

			return r.Unique.Count(i => members.Contains(i.Generator)) >= Math.Max(1, members.Count() * 2/3);
		}

		public bool QuorumFailed(Round r)
		{
			var max = VotersFor(r).Select(i => i.Generator);

			return r.Unique.Count() >= Math.Max(1, max.Count() * 2/3) && r.Majority.Count() + (max.Count() - r.Unique.Count()) < Math.Max(1, max.Count() * 2/3);
		}

		public ChainTime CalculateTime(Round round, IEnumerable<Payload> votes)
		{
 			if(round.Id == 0)
 			{
 				return round.Time;
 			}

 			if(!votes.Any())
 			{
				return round.Previous.Time + new ChainTime(1);
			}

			///var t = 0L;
			///var n = 0;
			///
			///for(int i = Math.Max(0, round.Id - Pitch + 1); i <= round.Id; i++)
			///{
			///	var r = FindRound(i);
			///	t += r.Payloads.Sum(i => i.Time.Ticks);
			///	n += r.Payloads.Count();
			///}
			///
			///t /= n;

			return round.Previous.Time + new ChainTime(votes.Sum(i => i.TimeDelta)/votes.Count());
		}

		public IEnumerable<Transaction> CollectValidTransactions(IEnumerable<Transaction> txs, Round round)
		{
			txs = txs.Where(i => round.Id <= i.RoundMax /*&& IsSequential(i, round.Id)*/);

			if(txs.Any())
			{
// 				var p = new Payload(this);
// 				p.Member	= Account.Zero;
// 				p.Time		= DateTime.UtcNow;
// 				p.Round		= round;
// 				p.TimeDelta	= 1;
// 					
// 				foreach(var i in txs)
// 				{
// 					p.AddNext(i);
// 				}
// 				
//  				Execute(round, new Payload[] {p}, null);
 	
 //				txs = txs.Where(t => t.SuccessfulOperations.Any());
			}

			return txs;
		}

		//public bool IsSequential(Transaction transaction, int ridmax)
		//{
		//	var prev = Accounts.FindLastTransaction(transaction.Signer, t => t.Successful, null, r => r.Id < ridmax);
		//
		//	if(transaction.Id == 0 && prev == null)
		//		return true;
		//
		//	if(transaction.Id == 0 && prev != null || transaction.Id != 0 && prev != null && prev.Id != transaction.Id - 1)
		//		return false;
		//
		//	/// STRICT: return prev != null && (prev.Payload.Confirmed || prev.Payload.Transactions.All(i => IsSequential(i, i.Payload.RoundId))); /// All transactions in a block containing 'prev' one must also be sequential
		//	return prev.Payload.Confirmed || IsSequential(prev, prev.Payload.RoundId);
		//}

		///public bool IsSequential(Operation transaction, int ridmax)
		///{
		///	var prev = Accounts.FindLastOperation(transaction.Signer, o => o.Successful, t => t.Successful, null, r => r.Id < ridmax);
		///
		///	if(transaction.Id == 0 && prev == null)
		///		return true;
		///
		///	if(transaction.Id == 0 && prev != null || transaction.Id != 0 && prev != null && prev.Id != transaction.Id - 1)
		///		return false;
		///
		///	/// STRICT: return prev != null && (prev.Payload.Confirmed || prev.Payload.Transactions.All(i => IsSequential(i, i.Payload.RoundId))); /// All transactions in a block containing 'prev' one must also be sequential
		///	return prev.Transaction.Payload.Confirmed || IsSequential(prev, prev.Transaction.Payload.RoundId);
		///}

		public RoundReference Refer(Round round)
		{
			if(round.Id < Pitch)
				return RoundReference.Empty;

			//byte [] hash(Round r, IEnumerable<Payload> votedfor) /// hash referred round and previous [Pitch-1] ones
			//{
			//	var s = new MemoryStream();
			//	var w = new BinaryWriter(s);
			//	//
			//	//for(int i = Math.Max(0, last.Id - Roundchain.Pitch + 1); i < last.Id; i++) /// previous [Pitch-1] rounds
			//	//{
			//	//	var r = FindRound(i);
			//	//
			//	//	if(r.Id > LastGenesisRound && !r.Confirmed)
			//	//	{
			//	//		return null;
			//	//	}
			//	//
			//	//	w.Write(i < Pitch ? Cryptography.ZeroHash : r.Hash);
			//	//}
			//
			//	w.Write(last.Hash);
			//
			//	foreach(var p in votedfor) /// referred round itself
			//	{
			//		r.WriteConfirmed(w);
			//	}
			//
			//	return Cryptography.Current.Hash(s.ToArray());
			//}

			//var p = round.Parent;

			if(!round.Parent.Confirmed && round.Id > LastGenesisRound)
				return null;

			var pp = round.Unique	.OfType<Payload>()	
									.GroupBy(i => i.Reference)
									.Aggregate((i, j) => i.Count() > j.Count() ? i : j)
									.OrderBy(i => i.OrderingKey, new BytesComparer());
			
			//var h = hashpitch(p, );		/// get candidates' its own referance hash, [parent.Id - Pitch + 1 .. parent.Id]
																								/// must always return non-null cause all of rounds must be already confirmed

			//var payloads = round.Unique.OfType<Payload>().Where(i => i.Reference.Hash.SequenceEqual(round.ParentId < Pitch ? RoundReference.Empty.Hash : h));	/// refers to correct confirmed [Pitch] number of parent rounds
			//
			//if(payloads.Any())
			//	payloads = payloads.GroupBy(i => i.Reference).Aggregate((i, j) => i.Count() > j.Count() ? i : j); /// take majority if any
			//else
			//	payloads = payloads;
			//
			//payloads = payloads.OrderBy(i => i.OrderingKey, new BytesComparer());
			//
			//h = hash(round, payloads); /// now get the hash to this round and [Pitch-1] of previous
			//
			//if(h == null) 
			//	return null; /// some of previous [Pitch-1] rounds is not confirmed

			var rr = new RoundReference();

			//rr.Hash					= h;
			rr.Payloads		= pp.						Select(i => i.Prefix).ToList();
			rr.Violators	= round.ElectedViolators.	Select(i => i.Prefix).ToList();
			rr.Leavers		= round.ElectedLeavers.		Select(i => i.Prefix).ToList();
			rr.Joiners		= round.ElectedJoiners.		Select(i => i.Prefix).OrderBy(i => i, new BytesComparer()).Take(rr.Leavers.Count + NewMembersPerRoundMax).ToList();
			rr.HubLeavers	= round.ElectedHubLeavers.	Select(i => i.GetAddressBytes()).ToList();
			rr.HubJoiners	= round.ElectedHubJoiners.	Select(i => i.GetAddressBytes()).OrderBy(i => i, new BytesComparer()).Take(rr.HubLeavers.Count + NewHubsPerRoundMax).ToList();
			rr.FundLeavers	= round.ElectedFundLeavers.	Select(i => i.Prefix).ToList();
			rr.FundJoiners	= round.ElectedFundJoiners.	Select(i => i.Prefix).ToList();
			rr.Time			= CalculateTime(round, pp);

			return rr;
		}

		public void Execute(Round round, IEnumerable<Payload> payloads, IEnumerable<Account> blockforkers)
		{
			var prev = round.Previous;
				
			if(round.Id != 0 && prev == null)
				return;

			round.Members			= Members.ToList();
			round.Funds				= Funds.ToList();
			round.Hubs				= Hubs.ToList();
			round.ExecutingPayloads = payloads;
			round.Time				= CalculateTime(round, payloads);

			round.AffectedAccounts.Clear();
			round.AffectedAuthors.Clear();
			round.AffectedProducts.Clear();
			round.AffectedRounds.Clear();

			round.Emission	= round.Id == 0 ? 0						: (prev == LastSavedRound ?	LastSavedEmission	: prev.Emission);
			round.WeiSpent	= round.Id == 0 ? 0						: (prev == LastSavedRound ?	LastSavedWeiSpent	: prev.WeiSpent);
			round.Factor	= round.Id == 0 ? Emission.FactorStart	: (prev == LastSavedRound ?	LastSavedFactor		: prev.Factor);

			foreach(var b in round.ExecutingPayloads.Reverse())
				foreach(var t in b.Transactions.AsEnumerable().Reverse())
					foreach(var o in t.Operations)
					{
						o.Executed = false;
						o.Error = null;
					}

			foreach(var b in round.ExecutingPayloads.Reverse())
			{
				foreach(var t in b.Transactions.AsEnumerable().Reverse())
				{
					Coin fee = 0;

					foreach(var o in t.Operations.AsEnumerable().Reverse())
					{
						var l = round.ChangeAccount(t.Signer).FindOperation<Operation>(round);
					
						if(/*l == null && o.Id != 0 ||*/ l != null && o.Id <= l.Id)
						{
							o.Error = "Non sequential";
							break;
						}
						
						o.Execute(this, round);
						o.Executed = true;

// 						if(o.Error != null)
// 							break;

						if(o.Error == null)
						{
							var f = o.CalculateFee(round.Factor);
	
							if(round.ChangeAccount(t.Signer).Balance - f >= 0)
							{
								fee += f;
								round.ChangeAccount(t.Signer).Balance -= f;
							}
							else
							{
								o.Error = Operation.NotEnoughUNT;
	//							break;
							}
						}
					}
						
					if(t.SuccessfulOperations.Any())
					{
						round.ChangeAccount(t.Signer).Transactions.Add(round.Id);
						round.Distribute(fee, new [] {b.Generator}, 9, round.Funds, 1); /// this way we prevent a member from sending his own transactions using his own blocks for free, this could be used for block flooding 
					}
				}
			}


			if(round.Id > LastGenesisRound)
			{
				var penalty = Coin.Zero;

				if(blockforkers != null && blockforkers.Any())
				{
					foreach(var f in blockforkers)
					{
						penalty += Accounts.FindLastOperation<CandidacyDeclaration>(f, o => o.Successful, null, null, i => i.Id < round.Id).Bail;
						round.ChangeAccount(f).BailStatus = BailStatus.Siezed;
					}

					round.Distribute(penalty, round.Members.Where(i => !blockforkers.Contains(i.Generator)).Select(i => i.Generator), 1, round.Funds, 1);
				}
			}
			//ExecuteWithoutErrors(round, payloads, blockforkers);
		}

		public void Confirm(Round round)
		{
			if(round.Id > 0 && LastConfirmedRound.Id + 1 != round.Id)
				throw new IntegrityException("LastConfirmedRound.Id + 1 == round.Id");

			List<T>	confirm<T>(IEnumerable<byte[]> prefixes, Func<Vote, IEnumerable<T>> get, Func<T, byte[]> getprefix)
			{
				var o = prefixes.Select(v => round.Unique.SelectMany(i => get(i)).FirstOrDefault(i => getprefix(i).SequenceEqual(v)));

				if(o.Contains(default(T)))
					throw new ConfirmationException("Can't confirm, some references not found", round);
				else 
					return o.ToList();
			}

			/// check we have all payload blocks 

			foreach(var i in round.Payloads)
				i.Confirmed = false;

			var child = FindRound(round.Id + Pitch);
			var rf = child.Majority.First().Reference;
 	
			foreach(var pf in rf.Payloads)
			{
				var b = round.Unique.FirstOrDefault(i => pf.SequenceEqual(i.Prefix));

				if(b != null)
					b.Confirmed = true;
				else
					return; // Some block(s) not present
			}

			round.Blocks.RemoveAll(i => i is Payload p && !p.Confirmed);

			round.ConfirmedViolators	= confirm(rf.Violators,		i => i.Violators,	i => i.Prefix);
			round.ConfirmedJoiners		= confirm(rf.Joiners,		i => i.Joiners,		i => i.Prefix);
			round.ConfirmedLeavers		= confirm(rf.Leavers,		i => i.Leavers,		i => i.Prefix);
			round.ConfirmedHubJoiners	= confirm(rf.HubJoiners,	i => i.HubJoiners,	i => i.GetAddressBytes());
			round.ConfirmedHubLeavers	= confirm(rf.HubLeavers,	i => i.HubLeavers,	i => i.GetAddressBytes());
			round.ConfirmedFundJoiners	= confirm(rf.FundJoiners,	i => i.FundJoiners, i => i.Prefix);
			round.ConfirmedFundLeavers	= confirm(rf.FundLeavers,	i => i.FundLeavers, i => i.Prefix);
			round.Time					= rf.Time;

			round.Confirmed = true;

			Seal(round);
		}

		public void Seal(Round round)
		{
			Execute(round, round.ConfirmedPayloads, round.ConfirmedViolators);

			foreach(var b in round.Payloads)
				foreach(var t in b.Transactions)
					foreach(var o in t.Operations)
						o.Placing = b.Confirmed && o.Successful ? PlacingStage.Confirmed : PlacingStage.FailedOrNotFound;

			round.Seal();

			Members.AddRange(round.ConfirmedJoiners.Select(i =>	{
																	var d = Accounts.FindLastOperation<CandidacyDeclaration>(i, o => o.Successful, null, null, r => r.Id < round.Id);
																	return new Peer {Generator = i, IP = d.IP, JoinedGeneratorsAt = round.Id + Pitch};
																}));

			Members.RemoveAll(i => round.AnyOperation(o => o is CandidacyDeclaration d && d.Signer == i.Generator && o.Placing == PlacingStage.Confirmed));  /// CandidacyDeclaration cancels membership
			Members.RemoveAll(i => round.AffectedAccounts.ContainsKey(i.Generator) && round.AffectedAccounts[i.Generator].Bail < (Settings.Dev.DisableBailMin ? 0 : BailMin));  /// if Bail has exhausted due to penalties (CURRENTY NOT APPLICABLE, penalties are disabled)
			Members.RemoveAll(i => round.ConfirmedLeavers.Contains(i.Generator));
			Members.RemoveAll(i => round.ConfirmedViolators.Contains(i.Generator));

			if(round.Id <= LastGenesisRound || round.Factor == Emission.FactorEnd) /// reorganization only after emission is over
			{
				Funds.AddRange(round.ConfirmedFundJoiners);
				Funds.RemoveAll(i => round.ConfirmedFundLeavers.Contains(i));
			}

			Hubs.AddRange(round.ConfirmedHubJoiners.Select(i => new Peer(i){JoinedHubsAt = round.Id}));
			Hubs.RemoveAll(i => round.ConfirmedHubLeavers.Contains(i.IP));

			//if(Hubs.Count > HubsMax)
			//{
			//	Hubs.OrderByDescending(i => i.JoinedHubsAt).ThenBy(i => i.IP.GetAddressBytes(), new BytesComparer())
			//} 

 			round.Members	= Members.ToList();
 			round.Funds		= Funds.ToList();
 			round.Hubs		= Hubs.ToList();

			if(round.Id - Rounds.Last().Id > Pitch + Pitch + 1) /// keep last [Pitch] sealed rounds cause [LastSealed - Pitch] round may contain JoinRequests that are needed if a node is joining
			{
				var r = Rounds.Last();

				using(var b = new WriteBatch())
				{
					b.Put(LastRoundKey, BitConverter.GetBytes(r.Id));
					b.Put(WeiSpentKey,	r.WeiSpent.ToByteArray());
					b.Put(FactorKey,	r.Factor.Attos.ToByteArray());
					b.Put(EmissionKey,	r.Emission.Attos.ToByteArray());

					Accounts.Save(b, r.AffectedAccounts.Values);
					Authors.Save(b, r.AffectedAuthors.Values);
					Products.Save(b, r.AffectedProducts.Values);

					var s = new MemoryStream();
					var w = new BinaryWriter(s);
					w.Write(r.Members, i => i.WriteMember(w));
					b.Put(MembersKey, s.ToArray());

					s = new MemoryStream();
					w = new BinaryWriter(s);
					w.Write(r.Funds);
					b.Put(FundablesKey, s.ToArray());

					foreach(var i in r.AffectedRounds)
					{
						s = new MemoryStream();
						w = new BinaryWriter(s);
						
						i.Save(w);
						b.Put(BitConverter.GetBytes(i.Id), s.ToArray(), RoundsFamily);
					}

					s = new MemoryStream(); /// may duplicate above if affected, not big deal
					w = new BinaryWriter(s);
						
					r.Save(w);
					b.Put(BitConverter.GetBytes(r.Id), s.ToArray(), RoundsFamily);

					Database.Write(b);
				}
				
				Rounds.Remove(r);
				
				/// to save RAM
				r.Members = null;
				r.Funds = null;
				r.Hubs = null;
				r.AffectedAccounts = null;
				r.AffectedAuthors = null;
				r.AffectedProducts = null;
				r.Blocks.RemoveAll(i => !i.Confirmed);

				r.LastAccessed	= DateTime.UtcNow;
				LoadedRounds[r.Id] = r;

				Recycle();
			}
		}


		public ProductEntry FindProduct(ProductAddress authorproduct, int ridmax)
		{
			foreach(var r in Rounds.Where(i => i.Id <= ridmax))
				if(r.AffectedProducts.ContainsKey(authorproduct))
					return r.AffectedProducts[authorproduct];

			var e = Products.FindEntry(authorproduct);

			if(e != null && (e.LastRegistration > ridmax))
				throw new IntegrityException("maxrid works inside pool only");

			return e;
		}

		public Transaction FindLastPoolTransaction(Func<Transaction, bool> transaction_predicate, Func<Payload, bool> payload_predicate = null, Func<Round, bool> round_predicate = null)
		{
			foreach(var r in round_predicate == null ? Rounds : Rounds.Where(round_predicate))
				foreach(var b in payload_predicate == null ? r.Payloads : r.Payloads.Where(payload_predicate))
					foreach(var t in b.Transactions)
						if(transaction_predicate == null || transaction_predicate(t))
							return t;

			return null;
		}

		public IEnumerable<Transaction> FindLastPoolTransactions(Func<Transaction, bool> transaction_predicate, Func<Payload, bool> payload_predicate = null, Func<Round, bool> round_predicate = null)
		{
			foreach(var r in round_predicate == null ? Rounds : Rounds.Where(round_predicate))
				foreach(var b in payload_predicate == null ? r.Payloads : r.Payloads.Where(payload_predicate))
					foreach(var t in transaction_predicate == null ? b.Transactions : b.Transactions.Where(transaction_predicate))
						yield return t;
		}

		public O FindLastPoolOperation<O>(Func<O, bool> op = null, Func<Transaction, bool> tp = null, Func<Payload, bool> pp = null, Func<Round, bool> rp = null)
		{
			var ops = FindLastPoolTransactions(tp, pp, rp).SelectMany(i => i.Operations.OfType<O>());
			return op == null ? ops.FirstOrDefault() : ops.FirstOrDefault(op);
		}

		IEnumerable<O> FindLastPoolOperations<O>(Func<O, bool> op = null, Func<Transaction, bool> tp = null, Func<Payload, bool> pp = null, Func<Round, bool> rp = null)
		{
			var ops = FindLastPoolTransactions(tp, pp, rp).SelectMany(i => i.Operations.OfType<O>());
			return op == null ? ops : ops.Where(op);
		}

		public Block FindLastBlock(Func<Block, bool> f, int maxrid = int.MaxValue)
		{
			foreach(var r in Rounds.Where(i => i.Id <= maxrid))
				foreach(var b in r.Blocks)
					if(f(b))
						return b;

			return null;
		}

		public IEnumerable<Block> FindLastBlocks(Func<Block, bool> f, int maxrid = int.MaxValue)
		{
			foreach(var r in Rounds.Where(i => i.Id <= maxrid))
				foreach(var b in r.Blocks)
					if(f(b))
						yield return b;
		}

		public IEnumerable<ReleaseManifest> FindReleases(string author, string product, Func<ReleaseManifest, bool> f, int maxrid = int.MaxValue)
		{
			throw new NotImplementedException();

///			return FindLastPoolOperations<Release>(i => i.Author == author && i.Product == product && f(i), rp: r => r.Id <= maxrid).Union(Products.FindReleases(author, product, f));
		}
		
		public AccountInfo GetAccountInfo(Account account, bool confirmed)
		{
			var roundmax = confirmed ? LastConfirmedRound : LastNonEmptyRound;

			var a = Accounts.Find(account, roundmax.Id);

			if(a != null)
			{
				var i = new AccountInfo();

				var t = Accounts.FindLastOperation(account, i => i.Successful);

				i.Balance			= a.Balance;
				i.LastOperationId	= t == null ? -1 : t.Id;
				i.Authors			= a.Authors;
				i.Operations		= Accounts.FindLastOperations<Operation>(account).Take(10).Reverse().Select(i => new AccountOperationInfo(i)).ToList();

				return i;
			}

			return null;
		}

		public XonDocument GetAuthorInfo(string author, bool confirmed, IXonValueSerializator serializator)
		{
			var roundmax = confirmed ? LastConfirmedRound : LastNonEmptyRound;

			var a = Authors.Find(author, roundmax.Id);

			if(a != null)
			{
				return a.ToXon(serializator);
			}

			return null;
		}
				
		public XonDocument QueryRelease(ReleaseQuery query, bool confirmed, IXonValueSerializator serializator)
		{
			if(query.VersionQuery == VersionQuery.Latest)
			{
				var roundmax = confirmed ? LastConfirmedRound : LastPayloadRound;
	
				var p = Products.Find(query, roundmax.Id);
	
				if(p != null)
				{
					var r = p.Releases.Find(i => i.Channel == query.Channel && i.Platform == query.Platform);
					
					if(r != null)
					{
						var prev = FindRound(r.Rid).FindOperation<ReleaseManifest>(m =>	m.Address.Author == query.Author && 
																						m.Address.Product == query.Product && 
																						m.Address.Platform == query.Platform && 
																						m.Channel == query.Channel);
	
						return prev.ToXon(serializator);
					}
				}

				return null;
			}

			throw new InvalidRequestException("Unknown VersionQuery");
		}
	}
}
