// Disable warnings generated by the Windows header files.
//#pragma warning(disable : 4514)
//#pragma warning(disable : 4201)


#include "stdafx.h"

#if 0
#include <tchar.h>
#include <dbghelp.h>
#include "ExceptionHandler.h"
#include "GetWinVer.h"
#include "../UO.CrashReport/CrashReport.h"

#include <tlhelp32.h>

using namespace uos;

#ifndef _countof
	#define _countof(array) (sizeof(array)/sizeof(array[0]))
#endif

/*	
const int NumCodeBytes = 16;	// Number of code bytes to record.
const int MaxStackDump = 3072;	// Maximum number of DWORDS in stack dumps.
const int StackColumns = 4;		// Number of columns in stack dump.
*/	

///////////////////////////////////////////////////////////////////////////////
// lstrrchr (avoid the C Runtime )
static TCHAR * lstrrchr(LPCTSTR string, int ch)
{
	TCHAR *start = (TCHAR *)string;

	while (*string++)                       /* find end of string */
		;
	/* search towards front */
	while (--string != start && *string != (TCHAR) ch)
		;

	if (*string == (TCHAR) ch)                /* char found ? */
		return (TCHAR *)string;

	return null;
}

///////////////////////////////////////////////////////////////////////////////
// GetFilePart
static TCHAR * GetFilePart(LPCTSTR source)
{
	TCHAR *result = lstrrchr(source, _T('\\'));
	if (result)
		result++;
	else
		result = (TCHAR *)source;
	return result;
}


void wstrrpl(wchar_t * s, wchar_t * w, wchar_t * a, int s_size)
{
	int sn = wcslen(s);
	int wn = wcslen(w);
	int an = wcslen(a);
	
	wchar_t * p = wcsstr(s, w);
	
	if(p!=null)
	{
		int n = p-s;
		int bn = sn + an + 2;
		wchar_t * b = (wchar_t *)malloc(bn*sizeof(wchar_t));
		ZeroMemory(b, bn*sizeof(wchar_t));

		wcsncat_s(b,		bn,			s,		n);
		wcsncat_s(b+n,		bn-n,		a,		an);
		wcsncat_s(b+n+an,	bn-n-an,	p+wn,	(sn-n-wn));
		
		b[sn-wn+an] = L'\0';
							
		wcscpy_s(s, s_size, b);
		
		free(b);
	}
}

static void hprintf(HANDLE logFile, LPCTSTR format, ...)
{
	wchar_t b[64*1024];

	va_list arglist;
	va_start( arglist, format);
	wvsprintf(b, format, arglist);
	va_end( arglist);

	DWORD NumBytes;
	WriteFile(logFile, b, lstrlen(b)*sizeof(wchar_t), &NumBytes, 0);
}

static void CreateMiniDump(HANDLE hFile, PEXCEPTION_POINTERS excpInfo)
{
	if (excpInfo == null) 
	{
		// Generate exception to get proper context in dump
		__try 
		{
			RaiseException(EXCEPTION_BREAKPOINT, 0, 0, null);
		} 
		__except(CreateMiniDump(hFile, GetExceptionInformation()), EXCEPTION_CONTINUE_EXECUTION) 
		{
		}
	} 
	else
	{
		MINIDUMP_EXCEPTION_INFORMATION eInfo;
		eInfo.ThreadId			= GetCurrentThreadId();
		eInfo.ExceptionPointers = excpInfo;
		eInfo.ClientPointers	= FALSE;

		// note:  MiniDumpWithIndirectlyReferencedMemory does not work on Win98
		MiniDumpWriteDump(GetCurrentProcess(), GetCurrentProcessId(), hFile, /*MiniDumpWithFullMemory*/MiniDumpWithDataSegs, excpInfo ? &eInfo : null, null, null);
	}
}

static void FormatTime(LPTSTR output, FILETIME TimeToPrint)
{
	output[0] = _T('\0');
	WORD Date, Time;
	if (FileTimeToLocalFileTime(&TimeToPrint, &TimeToPrint) && FileTimeToDosDateTime(&TimeToPrint, &Date, &Time))
	{
		wsprintf(output, _T("%d/%d/%d %02d:%02d:%02d"),	(Date / 32) & 15, Date & 31, (Date / 512) + 1980, (Time >> 11), (Time >> 5) & 0x3F, (Time & 0x1F) * 2);
	}
}

static void GetVersionValue(TCHAR * filepath, TCHAR * name, TCHAR * v, UINT vsizeInChars)
{
	BOOL rc;
	DWORD *pdwTranslation;
	UINT nLength;

	*v = '\0';

	int size = ::GetFileVersionInfoSize(filepath, null);
	if(size > 0)
	{
		void * p = _malloca(size);
		::GetFileVersionInfo(filepath, 0, size, p);

		rc = ::VerQueryValue(p, L"\\VarFileInfo\\Translation", (void**) &pdwTranslation, &nLength);
		if(rc)
		{
			TCHAR szKey[32768];
			wsprintf(szKey, L"\\StringFileInfo\\%04x%04x\\%s", LOWORD (*pdwTranslation), HIWORD (*pdwTranslation),	name);	

			UINT l;
			wchar_t * b;
			rc = VerQueryValue(p, szKey, (void **)&b, &l);
			if(rc)
			{
				wcscpy_s(v, vsizeInChars, b);
			}
		}
		_freea(p);
	}
}


VS_FIXEDFILEINFO GetVersion(TCHAR * filepath)
{
	VS_FIXEDFILEINFO out;
	ZeroMemory(&out, sizeof(out));
	
	int size = ::GetFileVersionInfoSize(filepath, null);
	if(size > 0)
	{
		void * p = _malloca(size);
		::GetFileVersionInfo(filepath, 0, size, p);
		UINT l;
		VS_FIXEDFILEINFO * vi;
		VerQueryValue(p, L"\\", (void **)&vi, &l);

		out = *vi;
	
		_freea(p);
	}
	return out;
}

static bool DumpModuleInfo(HANDLE logFile, HINSTANCE moduleHandle, int nModuleNo)
{
	bool rc = false;
	TCHAR szModName[MAX_PATH*2];
	ZeroMemory(szModName, sizeof(szModName));

	__try
	{
		if (GetModuleFileName(moduleHandle, szModName, sizeof(szModName)-2) > 0)
		{
			// If GetModuleFileName returns greater than zero then this must
			// be a valid code module address. Therefore we can try to walk
			// our way through its structures to find the link time stamp.
			IMAGE_DOS_HEADER *dosHeader = (IMAGE_DOS_HEADER*)moduleHandle;
			if (IMAGE_DOS_SIGNATURE != dosHeader->e_magic)
				return false;

			IMAGE_NT_HEADERS *NTHeader = (IMAGE_NT_HEADERS*)((char *)dosHeader + dosHeader->e_lfanew);
			if (IMAGE_NT_SIGNATURE != NTHeader->Signature)
				return false;

			// open the code module file so that we can get its file date and size
			HANDLE moduleFile = CreateFile(szModName, GENERIC_READ,	FILE_SHARE_READ, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);

			TCHAR TimeBuffer[100];
			TimeBuffer[0] = _T('\0');

			DWORD FileSize = 0;
			if (moduleFile != INVALID_HANDLE_VALUE)
			{
				FileSize = GetFileSize(moduleFile, 0);
				FILETIME LastWriteTime;
				if (GetFileTime(moduleFile, 0, 0, &LastWriteTime))
				{
					FormatTime(TimeBuffer, LastWriteTime);
				}
				CloseHandle(moduleFile);
			}
			hprintf(logFile, _T("Module %d\r\n"), nModuleNo);
			hprintf(logFile, _T("%s\r\n"), szModName);
			hprintf(logFile, _T("Image Base: 0x%08x  Image Size: 0x%08x\r\n"), NTHeader->OptionalHeader.ImageBase, NTHeader->OptionalHeader.SizeOfImage), 
			hprintf(logFile, _T("Checksum:   0x%08x  Time Stamp: 0x%08x\r\n"), NTHeader->OptionalHeader.CheckSum, NTHeader->FileHeader.TimeDateStamp);
			hprintf(logFile, _T("File Size:  %-10d  File Time:  %s\r\n"), FileSize, TimeBuffer);
			hprintf(logFile, _T("Version Information:\r\n"));

			TCHAR szBuf[200];
				
			GetVersionValue(szModName, L"CompanyName",		szBuf, _countof(szBuf));	hprintf(logFile, _T("   Company:    %s\r\n"), szBuf);
			GetVersionValue(szModName, L"ProductName",		szBuf, _countof(szBuf));	hprintf(logFile, _T("   Product:    %s\r\n"), szBuf);
			GetVersionValue(szModName, L"FileDescription",	szBuf, _countof(szBuf));	hprintf(logFile, _T("   FileDesc:   %s\r\n"), szBuf);
			VS_FIXEDFILEINFO v = GetVersion(szModName);									hprintf(logFile, _T("   FileVer:    %d.%d.%d.%d\r\n"), HIWORD(v.dwFileVersionMS), LOWORD(v.dwFileVersionMS), HIWORD(v.dwFileVersionLS), LOWORD(v.dwFileVersionLS));
																						hprintf(logFile, _T("   ProdVer:    %d.%d.%d.%d\r\n"), HIWORD(v.dwProductVersionMS), LOWORD(v.dwProductVersionMS), HIWORD(v.dwProductVersionLS), LOWORD(v.dwProductVersionLS));
			hprintf(logFile, _T("\r\n"));

			rc = true;
		}
	}
	// Handle any exceptions by continuing from this point.
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
	}
	return rc;
}

static void DumpModuleList(HANDLE logFile)
{
	SYSTEM_INFO	SystemInfo;
	GetSystemInfo(&SystemInfo);

	const size_t pageSize = SystemInfo.dwPageSize;

	// Set NumPages to the number of pages in the 4GByte address space,
	// while being careful to avoid overflowing ints
	const size_t NumPages = 4 * size_t(1024*1024*1024 / pageSize);
	size_t pageNum = 0;
	void *LastAllocationBase = 0;

	int nModuleNo = 1;

	while (pageNum < NumPages)
	{
		MEMORY_BASIC_INFORMATION MemInfo;
		if (VirtualQuery((void *)(pageNum * pageSize), &MemInfo, sizeof(MemInfo)))
		{
			if (MemInfo.RegionSize > 0)
			{
				// Adjust the page number to skip over this block of memory
				pageNum += MemInfo.RegionSize / pageSize;
				if (MemInfo.State == MEM_COMMIT && MemInfo.AllocationBase >	LastAllocationBase)
				{
					// Look for new blocks of committed memory, and try
					// recording their module names - this will fail
					// gracefully if they aren't code modules
					LastAllocationBase = MemInfo.AllocationBase;
					if (DumpModuleInfo(logFile, (HINSTANCE)LastAllocationBase, nModuleNo))
					{
						nModuleNo++;
					}
				}
			}
			else
				pageNum += 65536 / pageSize;
		}
		else
			pageNum += 65536 / pageSize;

		// If VirtualQuery fails we advance by 64K because that is the
		// granularity of address space doled out by VirtualAlloc()
	}
	hprintf(logFile, _T("\r\n\r\n"));
}

static void DumpSystemInformation(HANDLE logFile)
{
	FILETIME CurrentTime;
	GetSystemTimeAsFileTime(&CurrentTime);
	TCHAR szTimeBuffer[100];
	FormatTime(szTimeBuffer, CurrentTime);

	hprintf(logFile, _T("Error occurred at %s.\r\n"), szTimeBuffer);

	TCHAR szModuleName[MAX_PATH*2];
	ZeroMemory(szModuleName, sizeof(szModuleName));
	if (GetModuleFileName(0, szModuleName, _countof(szModuleName)-2) <= 0)
		lstrcpy(szModuleName, _T("Unknown"));

	TCHAR szUserName[200];
	ZeroMemory(szUserName, sizeof(szUserName));
	DWORD UserNameSize = _countof(szUserName)-2;
	if (!GetUserName(szUserName, &UserNameSize))
		lstrcpy(szUserName, _T("Unknown"));

	hprintf(logFile, _T("%s, run by %s.\r\n"), szModuleName, szUserName);

	// print out operating system
	TCHAR szWinVer[32768];
	GetOSDisplayString(szWinVer, _countof(szWinVer));
	hprintf(logFile, _T("Operating system:  %s\r\n"), szWinVer);

	SYSTEM_INFO	SystemInfo;
	GetSystemInfo(&SystemInfo);
	hprintf(logFile, _T("%d processor(s), type %d.\r\n"), SystemInfo.dwNumberOfProcessors, SystemInfo.dwProcessorType);

	MEMORYSTATUS MemInfo;
	MemInfo.dwLength = sizeof(MemInfo);
	GlobalMemoryStatus(&MemInfo);

	// Print out info on memory, rounded up.
	hprintf(logFile, _T("%d%% memory in use.\r\n"),					MemInfo.dwMemoryLoad);
	hprintf(logFile, _T("%d MBytes physical memory.\r\n"),			(MemInfo.dwTotalPhys + 1024*1024 - 1) / 1024*1024);
	hprintf(logFile, _T("%d MBytes physical memory free.\r\n"),		(MemInfo.dwAvailPhys + 1024*1024 - 1) / 1024*1024);
	hprintf(logFile, _T("%d MBytes paging file.\r\n"),				(MemInfo.dwTotalPageFile + 1024*1024 - 1) / 1024*1024);
	hprintf(logFile, _T("%d MBytes paging file free.\r\n"),			(MemInfo.dwAvailPageFile + 1024*1024 - 1) / 1024*1024);
	hprintf(logFile, _T("%d MBytes user address space.\r\n"),		(MemInfo.dwTotalVirtual + 1024*1024 - 1) / 1024*1024);
	hprintf(logFile, _T("%d MBytes user address space free.\r\n"),	(MemInfo.dwAvailVirtual + 1024*1024 - 1) / 1024*1024);

	hprintf(logFile, _T("\r\n\r\n"));
}

static const TCHAR *GetExceptionDescription(DWORD ExceptionCode)
{
	struct ExceptionNames
	{
		DWORD	ExceptionCode;
		TCHAR *	ExceptionName;
	};

	ExceptionNames ExceptionMap[] =
	{
		{0x40010005, _T("a Control-C")},
		{0x40010008, _T("a Control-Break")},
		{0x80000002, _T("a Datatype Misalignment")},
		{0x80000003, _T("a Breakpoint")},
		{0xc0000005, _T("an Access Violation")},
		{0xc0000006, _T("an In Page Error")},
		{0xc0000017, _T("a No Memory")},
		{0xc000001d, _T("an Illegal Instruction")},
		{0xc0000025, _T("a Noncontinuable Exception")},
		{0xc0000026, _T("an Invalid Disposition")},
		{0xc000008c, _T("a CArray Bounds Exceeded")},
		{0xc000008d, _T("a Float Denormal Operand")},
		{0xc000008e, _T("a Float Divide by Zero")},
		{0xc000008f, _T("a Float Inexact Result")},
		{0xc0000090, _T("a Float Invalid Operation")},
		{0xc0000091, _T("a Float Overflow")},
		{0xc0000092, _T("a Float Stack Check")},
		{0xc0000093, _T("a Float Underflow")},
		{0xc0000094, _T("an Integer Divide by Zero")},
		{0xc0000095, _T("an Integer Overflow")},
		{0xc0000096, _T("a Privileged Instruction")},
		{0xc00000fD, _T("a Stack Overflow")},
		{0xc0000142, _T("a DLL Initialization Failed")},
		{0xe06d7363, _T("a Microsoft C++ Exception")},
	};

	for (int i = 0; i < sizeof(ExceptionMap) / sizeof(ExceptionMap[0]); i++)
		if (ExceptionCode == ExceptionMap[i].ExceptionCode)
			return ExceptionMap[i].ExceptionName;

	return _T("an Unknown exception type");
}


///////////////////////////////////////////////////////////////////////////////
//
// RecordExceptionInfo
//
///////////////////////////////////////////////////////////////////////////////

int RecordExceptionInfo(PEXCEPTION_POINTERS pExceptPtrs, LPCTSTR lpszMessage, wchar_t * supervisorFolderPath)
{
	static bool bFirstTime = true;
		
	#ifdef _DEBUG
		return EXCEPTION_CONTINUE_SEARCH;
	#endif

	if(IsDebuggerPresent())
	{
		return EXCEPTION_CONTINUE_SEARCH;
	}
	else
	{	
		if (!bFirstTime)	// Going recursive! That must mean this routine crashed!
			return EXCEPTION_CONTINUE_SEARCH;
		
		bFirstTime = false;
	
		// Create a filename to record the error information to.
		// Storing it in the executable directory works well.
	
		TCHAR szModuleName[MAX_PATH*2];
		TCHAR szCoreModuleName[MAX_PATH*2];
		TCHAR szFileName[MAX_PATH*2];
		
		ZeroMemory(szModuleName, sizeof(szModuleName));
		if (GetModuleFileName(0, szModuleName, _countof(szModuleName)-2) <= 0)
			lstrcpy(szModuleName, _T("Unknown"));

		wcscpy_s(szCoreModuleName, _countof(szCoreModuleName), PathFindFileName(szModuleName));

		PathRemoveFileSpec(szModuleName);
		
		PathCombine(szFileName, supervisorFolderPath, CRASHREPORT_ERROR_LOG_FILE);
	
		HANDLE logFile = CreateFile(szFileName, GENERIC_WRITE, 0, 0, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH, 0);
		if(logFile != INVALID_HANDLE_VALUE)
		{
			DWORD n;
			unsigned char b[2] = {255, 254};
			WriteFile(logFile, b, 2, &n, null);

			// Append to the error log
			SetFilePointer(logFile, 0, 0, FILE_END);
		
			// Print out a blank line to separate this error log from any previous ones
			//hprintf(hLogFile, _T("\r\n"));
		
			PEXCEPTION_RECORD Exception = pExceptPtrs->ExceptionRecord;
			PCONTEXT          Context   = pExceptPtrs->ContextRecord;
		
			TCHAR szCrashModulePathName[MAX_PATH*2];
			ZeroMemory(szCrashModulePathName, sizeof(szCrashModulePathName));
		
			TCHAR *pszCrashModuleFileName = _T("Unknown");
		
			MEMORY_BASIC_INFORMATION MemInfo;
		
			// VirtualQuery can be used to get the allocation base associated with a
			// code address, which is the same as the ModuleHandle. This can be used
			// to get the filename of the module that the crash happened in.
			if (VirtualQuery((void*)Context->Eip, &MemInfo, sizeof(MemInfo)) && (GetModuleFileName((HINSTANCE)MemInfo.AllocationBase, szCrashModulePathName, sizeof(szCrashModulePathName)-2) > 0))
			{
				pszCrashModuleFileName = GetFilePart(szCrashModulePathName);
			}
		
			// Print out the beginning of the error log in a Win95 error window
			// compatible format.
			hprintf(logFile, _T("%s caused %s (0x%08x) \r\nin module %s at %04x:%08x.\r\n\r\n"), szCoreModuleName, GetExceptionDescription(Exception->ExceptionCode), Exception->ExceptionCode, pszCrashModuleFileName, Context->SegCs, Context->Eip);
			hprintf(logFile, _T("Exception handler called in %s.\r\n"), lpszMessage);
		
			DumpSystemInformation(logFile);
		
			// If the exception was an access violation, print out some additional
			// information, to the error log and the debugger.
			if (Exception->ExceptionCode == STATUS_ACCESS_VIOLATION && Exception->NumberParameters >= 2)
			{
				TCHAR szDebugMessage[1000];
				const TCHAR* readwrite = _T("Read from");
				if (Exception->ExceptionInformation[0])
					readwrite = _T("Write to");
				wsprintf(szDebugMessage, _T("%s location %08x caused an access violation.\r\n"), readwrite, Exception->ExceptionInformation[1]);
		
				hprintf(logFile, _T("%s"), szDebugMessage);
				hprintf(logFile, _T("\r\n\r\n"));
			}
					
			DumpModuleList(logFile);
		
			CloseHandle(logFile);
		}
	
		///////////////////////////////////////////////////////////////////////////
		//
		// write minidump
		//
		///////////////////////////////////////////////////////////////////////////

		PathCombine(szFileName, supervisorFolderPath, CRASHREPORT_MINI_DUMP_FILE);

		HANDLE hMiniDumpFile = CreateFile(szFileName,	GENERIC_WRITE, 0, null,	CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH, null);
		if (hMiniDumpFile != INVALID_HANDLE_VALUE)
		{
			CreateMiniDump(hMiniDumpFile, pExceptPtrs);
			CloseHandle(hMiniDumpFile);
		}


		if(LaunchReport(supervisorFolderPath))
		{
			// XCrashReport.exe was successfully started, so
			// suppress the standard crash dialog
			return EXCEPTION_EXECUTE_HANDLER;
		}
		else
		{
			// XCrashReport.exe was not started - let
			// the standard crash dialog appear
			return EXCEPTION_CONTINUE_SEARCH;
		}
	}
}

BOOL uo::LaunchReport(wchar_t * supervisorFolderPath)
{
	BOOL result; 
	static bool isReportLaunched = false;

	if(!isReportLaunched)
	{
		TCHAR errorReportApp[MAX_PATH];
		ZeroMemory(errorReportApp, sizeof(errorReportApp));
		GetModuleFileName(0, errorReportApp, _countof(errorReportApp)-2);
		PathRemoveFileSpec(errorReportApp);
		PathAppend(errorReportApp, CRASHREPORT_APP_FILENAME);
		
		TCHAR thisApp[MAX_PATH];
		ZeroMemory(thisApp, sizeof(thisApp));
		GetModuleFileName(0, thisApp, _countof(thisApp)-2);
	
		TCHAR szCommandLine[MAX_PATH];
		lstrcpy(szCommandLine, errorReportApp);
		
		lstrcat(szCommandLine, _T(" "));
		lstrcat(szCommandLine, PathFindFileName(thisApp));

		lstrcat(szCommandLine, _T(" \""));
		lstrcat(szCommandLine, supervisorFolderPath);
		lstrcat(szCommandLine, _T("\""));
	
		STARTUPINFO si;
		ZeroMemory(&si, sizeof(si));
		si.cb = sizeof(si);
		si.dwFlags = STARTF_USESHOWWINDOW;
		si.wShowWindow = SW_SHOW;
	
		PROCESS_INFORMATION pi;
		ZeroMemory(&pi, sizeof(pi));
	
		result = CreateProcess(	null,			// name of executable module
								szCommandLine,	// command line string
								null,			// process attributes
								null,			// thread attributes
								FALSE,			// handle inheritance option
								0,				// creation flags
								null,			// new environment block
								null,			// current directory name
								&si,			// startup information
								&pi);			// process information
								
		if(!result)
		{
			isReportLaunched = true;
		}
	} 
	else
	{
		result = false;
	}

	return result;
}
#endif
